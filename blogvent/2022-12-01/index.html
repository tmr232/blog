<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Bit of Codeviz | Tamir Bahar</title><meta name=keywords content><meta name=description content="When I started my professional career I was not doing software engineering, but rather reverse-engineering. Taking a compiled binary, disassembling it, and trying to understand what it does. My job was essentially reading code, with the stated goal in my job description was &ldquo;vulnerability research&rdquo;. Since then, I moved to the other side, and am now doing &ldquo;forward engineering&rdquo;.
While it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you&rsquo;re comfortable with) we only write code, we know that this is not true."><meta name=author content="Tamir Bahar"><link rel=canonical href=https://tamir.dev/blogvent/2022-12-01/><link crossorigin=anonymous href=/assets/css/stylesheet.0b7a6a59f13c612205962144f1a8f43a859c4d814d43709a9e3e2b0e9353224b.css integrity="sha256-C3pqWfE8YSIFliFE8aj0OoWcTYFNQ3Canj4rDpNTIks=" rel="preload stylesheet" as=style><link rel=icon href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=16x16 href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=32x32 href=https://tamir.dev/images/profilepic.jpg><link rel=apple-touch-icon href=https://tamir.dev/images/profilepic.jpg><link rel=mask-icon href=https://tamir.dev/images/profilepic.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=webmention href=https://webmention.io/tamir.dev/webmention><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="A Bit of Codeviz"><meta property="og:description" content="When I started my professional career I was not doing software engineering, but rather reverse-engineering. Taking a compiled binary, disassembling it, and trying to understand what it does. My job was essentially reading code, with the stated goal in my job description was &ldquo;vulnerability research&rdquo;. Since then, I moved to the other side, and am now doing &ldquo;forward engineering&rdquo;.
While it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you&rsquo;re comfortable with) we only write code, we know that this is not true."><meta property="og:type" content="article"><meta property="og:url" content="https://tamir.dev/blogvent/2022-12-01/"><meta property="og:image" content="https://tamir.dev/images/profilepic.jpg"><meta property="article:section" content="blogvent"><meta property="article:published_time" content="2022-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-01T00:00:00+00:00"><meta property="og:site_name" content="Tamir Bahar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tamir.dev/images/profilepic.jpg"><meta name=twitter:title content="A Bit of Codeviz"><meta name=twitter:description content="When I started my professional career I was not doing software engineering, but rather reverse-engineering. Taking a compiled binary, disassembling it, and trying to understand what it does. My job was essentially reading code, with the stated goal in my job description was &ldquo;vulnerability research&rdquo;. Since then, I moved to the other side, and am now doing &ldquo;forward engineering&rdquo;.
While it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you&rsquo;re comfortable with) we only write code, we know that this is not true."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"BlogventüéÑ","item":"https://tamir.dev/blogvent/"},{"@type":"ListItem","position":2,"name":"A Bit of Codeviz","item":"https://tamir.dev/blogvent/2022-12-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Bit of Codeviz","name":"A Bit of Codeviz","description":"When I started my professional career I was not doing software engineering, but rather reverse-engineering. Taking a compiled binary, disassembling it, and trying to understand what it does. My job was essentially reading code, with the stated goal in my job description was \u0026ldquo;vulnerability research\u0026rdquo;. Since then, I moved to the other side, and am now doing \u0026ldquo;forward engineering\u0026rdquo;.\nWhile it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you\u0026rsquo;re comfortable with) we only write code, we know that this is not true.","keywords":[],"articleBody":"When I started my professional career I was not doing software engineering, but rather reverse-engineering. Taking a compiled binary, disassembling it, and trying to understand what it does. My job was essentially reading code, with the stated goal in my job description was ‚Äúvulnerability research‚Äù. Since then, I moved to the other side, and am now doing ‚Äúforward engineering‚Äù.\nWhile it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you‚Äôre comfortable with) we only write code, we know that this is not true. If fact, we spend a lot of our time reading code. Be it code reviews, reading docs, debugging, or finding that one line of code we need to stick in someone else‚Äôs face and say ‚ÄúSee!?!?!?! I told you!!!‚Äù.\nReading code is a vital part of any code-related role. Be it forward- or reverse-engineering. That said, the perspective if very different. I see that difference when talking to my friends about code, some of them being developers and other reverse-engineers. But I also see it in how I approach my tasks. My approach to reading code is dramatically different between development and reverse-engineering tasks.\nPart of it is the difference in goals - as a software developer, I want the code to work well. I am not (usually) looking for bugs, because I really don‚Äôt wanna find them. As a reverse-engineer bugs are what we‚Äôre looking for. This leads to a different perspective. In addition to that, as a developer I tend to let my hubris control me, assuming that I can write bug-free code. That I can understand the entire system. When researching code for vulnerabilities, the assumptions are different. First and foremost - all systems have bugs. We just need to find them. And second - systems are big. Too big. This means that we need to focus, get to the interesting parts of an unknown system as fast as possible.\nThis, in my opinion, also leads to very different tools.\nThe developer‚Äôs tool of choice is a code editor. Be it vi, or emacs, or VSCode, or any other editor. We read the code as text, and process it as text. The editor might give as some colors or linking, but its still text. When we want to know whether 2 functions are similar, we read them both. When we want to know if a function has a complex flow - we read it.\na truncate in Go, as rendered by the Goland IDE The reverse-engineer‚Äôs tool of choice is often IDA (or Binary Ninja or Ghidra or Hopper or something similar). While those tools do allow reading the disassembled code as text, they also offer an additional view - a graph view.\nsame function, in IDAs graph view With a bit of training and getting used to it, the Graph view allows a reverse-engineer to quickly discern the flow of the function. With green and red arrows denoting the true and false branches of a condition, blue lines denoting unconditional jumps, and bold lines for backlinks (usually loops).\nWhile the graph does not convey all the information about a function, it still conveys a lot. It makes it easy to see if two functions are similar, or if a function is complicated.\nI like this ability, and I miss it dearly in my developer tooling. So I started playing around with graph-visualization of functions in Go, to see how it turns out. Using the least amount of code I could - taking advantage of Go‚Äôs SSA1 libraries, and graphing using GraphViz - I managed to create something that, while initial, I‚Äôm very happy with. The project is called go-overview-graph and renders source-code and graphs side-by-side. Here are some example graphs, because they are so pretty! I highly recommend going over the website and having a look yourself!\nSingle Static Assignment¬†‚Ü©Ô∏é\n","wordCount":"645","inLanguage":"en","datePublished":"2022-12-01T00:00:00Z","dateModified":"2022-12-01T00:00:00Z","author":{"@type":"Person","name":"Tamir Bahar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamir.dev/blogvent/2022-12-01/"},"publisher":{"@type":"Organization","name":"Tamir Bahar","logo":{"@type":"ImageObject","url":"https://tamir.dev/images/profilepic.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamir.dev/ accesskey=h title="Tamir Bahar (Alt + H)">Tamir Bahar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamir.dev/blogvent/ title=blogventüéÑ><span>blogventüéÑ</span></a></li><li><a href=https://tamir.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://tamir.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://tamir.dev/index.xml title=rss><span>rss</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="13"><g transform="scale(1)"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></g></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamir.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://tamir.dev/blogvent/>BlogventüéÑ</a></div><h1 class=post-title>A Bit of Codeviz</h1><div class=post-meta><span title='2022-12-01 00:00:00 +0000 UTC'>Dec 1, 2022</span>&nbsp;¬∑&nbsp;645 words&nbsp;¬∑&nbsp;Tamir Bahar</div></header><div class=post-content><p>When I started my professional career I was not doing software engineering, but rather reverse-engineering.
Taking a compiled binary, disassembling it, and trying to understand what it does.
My job was essentially reading code, with the stated goal in my job description was &ldquo;vulnerability research&rdquo;.
Since then, I moved to the other side, and am now doing &ldquo;forward engineering&rdquo;.</p><p>While it is very tempting to say that as programmers (or developers, or software engineers, or whichever term you&rsquo;re comfortable with) we only write code,
we know that this is not true.
If fact, we spend a lot of our time reading code.
Be it code reviews, reading docs, debugging, or finding that one line of code we need to stick in someone else&rsquo;s face and say &ldquo;See!?!?!?! I told you!!!&rdquo;.</p><p>Reading code is a vital part of any code-related role. Be it forward- or reverse-engineering.
That said, the perspective if <em>very</em> different.
I see that difference when talking to my friends about code,
some of them being developers and other reverse-engineers.
But I also see it in how I approach my tasks.
My approach to reading code is dramatically different between development and reverse-engineering tasks.</p><p>Part of it is the difference in goals - as a software developer, I want the code to work well.
I am not (usually) looking for bugs, because I really don&rsquo;t wanna find them.
As a reverse-engineer bugs are what we&rsquo;re looking for.
This leads to a different perspective.
In addition to that, as a developer I tend to let my hubris control me,
assuming that I <em>can</em> write bug-free code.
That I <em>can</em> understand the entire system.
When researching code for vulnerabilities, the assumptions are different.
First and foremost - all systems have bugs. We just need to find them.
And second - systems are big. Too big.
This means that we need to focus, get to the interesting parts of an unknown system as fast as possible.</p><p>This, in my opinion, also leads to <em>very</em> different tools.</p><p>The developer&rsquo;s tool of choice is a code editor.
Be it vi, or emacs, or VSCode, or any other editor.
We read the code as text, and process it as text.
The editor might give as some colors or linking, but its still text.
When we want to know whether 2 functions are similar, we read them both.
When we want to know if a function has a complex flow - we read it.</p><p><figure><img src=/images/blogvent-2022/go-fmt-truncate-text.png alt="&amp;ldquo;a truncate in Go, as rendered by the Goland IDE&amp;rdquo;"><figcaption>a truncate in Go, as rendered by the Goland IDE</figcaption></figure></p><p>The reverse-engineer&rsquo;s tool of choice is often <a href=https://hex-rays.com/>IDA</a> (or <a href=https://binary.ninja/>Binary Ninja</a> or <a href=https://github.com/NationalSecurityAgency/ghidra>Ghidra</a> or <a href=https://www.hopperapp.com/>Hopper</a> or something similar).
While those tools do allow reading the disassembled code as text, they also offer an additional view - a graph view.</p><p><figure><img src=/images/blogvent-2022/go-fmt-truncate-ida.png alt="&amp;ldquo;same function, in IDAs graph view&amp;rdquo;"><figcaption>same function, in IDAs graph view</figcaption></figure></p><p>With a bit of training and getting used to it, the Graph view allows a reverse-engineer to quickly discern the flow of the function. With green and red arrows denoting the true and false branches of a condition, blue lines denoting unconditional jumps, and bold lines for backlinks (usually loops).</p><p>While the graph does not convey all the information about a function, it still conveys a lot.
It makes it easy to see if two functions are similar, or if a function is complicated.</p><p>I like this ability, and I miss it dearly in my developer tooling.
So I started playing around with graph-visualization of functions in Go, to see how it turns out.
Using the least amount of code I could - taking advantage of Go&rsquo;s SSA<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> libraries, and graphing using <a href=https://graphviz.org/>GraphViz</a> - I managed to create something that, while initial, I&rsquo;m very happy with.
The project is called <a href=https://tmr232.github.io/go-overview-graph>go-overview-graph</a> and renders source-code and graphs side-by-side. Here are some example graphs, because they are so pretty!
I highly recommend going over the website and having a look yourself!</p><p><img src=/images/blogvent-2022/graph-01.png alt="Graph of a small function">
<img src=/images/blogvent-2022/graph-02.png alt="another graph of small function">
<img src=/images/blogvent-2022/graph-03.png alt="graph of a large and complex function"></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://en.wikipedia.org/wiki/Static_single-assignment_form>Single Static Assignment</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tamir.dev/>Tamir Bahar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>