<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Finalizing Mutexes | Tamir Bahar</title><meta name=keywords content><meta name=description content="Looking into the release of Mutexes in GC languages"><meta name=author content="Tamir Bahar"><link rel=canonical href=https://tamir.dev/posts/resource-management-02/><link crossorigin=anonymous href=/assets/css/stylesheet.0b7a6a59f13c612205962144f1a8f43a859c4d814d43709a9e3e2b0e9353224b.css integrity="sha256-C3pqWfE8YSIFliFE8aj0OoWcTYFNQ3Canj4rDpNTIks=" rel="preload stylesheet" as=style><link rel=icon href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=16x16 href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=32x32 href=https://tamir.dev/images/profilepic.jpg><link rel=apple-touch-icon href=https://tamir.dev/images/profilepic.jpg><link rel=mask-icon href=https://tamir.dev/images/profilepic.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=webmention href=https://webmention.io/tamir.dev/webmention><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Finalizing Mutexes"><meta property="og:description" content="Looking into the release of Mutexes in GC languages"><meta property="og:type" content="article"><meta property="og:url" content="https://tamir.dev/posts/resource-management-02/"><meta property="og:image" content="https://tamir.dev/images/profilepic.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-13T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-13T00:00:00+00:00"><meta property="og:site_name" content="Tamir Bahar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tamir.dev/images/profilepic.jpg"><meta name=twitter:title content="Finalizing Mutexes"><meta name=twitter:description content="Looking into the release of Mutexes in GC languages"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamir.dev/posts/"},{"@type":"ListItem","position":2,"name":"Finalizing Mutexes","item":"https://tamir.dev/posts/resource-management-02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Finalizing Mutexes","name":"Finalizing Mutexes","description":"Looking into the release of Mutexes in GC languages","keywords":[],"articleBody":"Once I define a model for thinking, I find that it is good to keep running it over in your mind, and see how it applies to different situations. To see if it holds for all cases, or if there are edge-cases that make it fall apart; or to see if there are interesting things to learn when applying it to real-world scenarios.\nSo, having talked about resources in my previous post, I spend some time thinking about interesting edge-cases with resource-management in GC languages. After a while, I thought about mutexes and locks. They are an interesting example as they are usually made up of 2 separate resources.\nLocks \u0026 Mutexes When we think about locks, there is one obvious acquire-use-release cycle we think about. We acquire the lock, use the resource it guards, then release the lock when we‚Äôre done.\n1 2 3 with thing.lock: # Acquire the lock thing.modify() # Use the guarded resource # Release the lock as we exit the scope But in most cases, we have another resource - the lock itself. On Windows, for example, a mutex can be creates using the CreateMutex function. That, in turn, returns a handle to the OS-level mutex. When we‚Äôre done using it, we need to call CloseHandle to close the handle and have the OS release the mutex. But‚Ä¶ I never released a mutex in Python. So what‚Äôs going on?\nPython‚Äôs threading.Lock First, I wanted to make sure Python‚Äôs threading.Lock is indeed backed by an OS-level mutex. I could read the code, but there are simpler ways.\nProcess Explorer allows us to see the number of handles used by a process. So if we create some locks, we should see the handle-count increasing.\n1 2 3 4 5 6 7 8 from threading import Lock # Wait for input, so that we can open the process in ProcExp input() # Create 100 locks locks = [Lock() for _ in range(100)] # Wait for input, so that we can see the increase input() At first, we see that we have 92 handles: Then we press Enter, and see the number increase to 192: Which is what we expected. This indicates that Python‚Äôs threading.Lock is indeed backed by an OS mutex in Windows. But‚Ä¶ We never release those mutexes ourselves, so what is going on?\nFirst, we need to make sure Python does not simply leak those resources. By adding the following lines to our code:\n1 2 3 # Delete the locks, so that they can be released del locks input() We can see that after del locks, the handle count drops back down to 92. So how does this happen?\nFinalizers \u0026 The __del__ Method To handle such cases, Python uses finalizers, implemented using the __del__ method. The __del__ method is called when an object is about to be destroyed. As Python is a GC language, the language runtime owns the objects, and is responsible for destroying them at its own time. This means that while it can be called immediately after we run del locks, it can also be called much later, or not at all. Our only guarantee is that if and when the GC reclaims the memory of our object, it‚Äôll also call the __del__ method to clean it up properly.\nThis is bad for unique-resources, and is why we use a context-manager to manage the lock itself. But for counted-resources, like the OS handle representing the mutex itself - this is a good solution. Even if the finalizer is not called before our process terminates, the OS itself will be sure to release those handles upon process termination.\nLessons Learned From this we learn a new lesson about Python, and our model. For unique-resources, we want to use context-managers, to ensure release at the right time. For counted-resources, we can use finalizers, and know that it‚Äôs good enough. In real code, we‚Äôll see that finalizers are usually used to wrap OS resources, and almost never user-defined-resources.\nOther Languages Now that we know how Python handles counted-resources, we can have a look at some more languages.\nJava \u0026 C# In Java, things are roughly the same. It‚Äôs another object-oriented language, and it uses finalizers for the same purposes. C# behaves similarly, being another object-oriented language. I will venture a guess, and say that most GC object-oriented languages use finalizers.\nBut, not all GC languages are object-oriented. Go, for example, is not. As such, it is interesting to see how it tackles the same problem.\nGo Looking at A Tour of Go, we see that mutexes are used as simple structs. There‚Äôs no NewMutex() function nor CloseMutex(). This is odd, as Go does not have finalizers. But, looking at the implementation of the sync.Mutex struct things become clear:\n1 2 3 4 type Mutex struct { state int32 sema uint32 } Go mutexes are not backed by OS mutexes. This is probably because Go uses goroutines instead of OS-level threads, and manages its own concurrency. Nice going, Go!\nBut what of other OS-level objects? Go can make its own mutexes, but sockets, for example, must go through the OS.\nSockets In Python, sockets are managed the same way mutexes are. You can change the threading.Lock to socket.socket in the code we used above to see the effects. In Go, however, they opted for a different solution. Instead of having a ‚Äúsocket‚Äù object, they have ‚Äúconnection‚Äù objects. Those connection objects are obviously unique-resources, as one needs to close their connections (that‚Äôs true in Python as well!). So by modifying the API, they remain consistent and avoid leaks.\nFinal Words By taking our model and applying to it different situations, we managed to learn some new things and reach new insights.\nWe learned about finalizers, and how they are used to manage counted-resources in GC languages. And we learned about Go‚Äôs scheduling, with their own mutexes; and their clever choices in the socket API to handle the lack of finalizers.\nAs we keep pushing our understanding of programming languages, and trying to apply it to more situations, I‚Äôm sure we‚Äôll learn a lot more.\n","wordCount":"1018","inLanguage":"en","datePublished":"2023-08-13T00:00:00Z","dateModified":"2023-08-13T00:00:00Z","author":{"@type":"Person","name":"Tamir Bahar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamir.dev/posts/resource-management-02/"},"publisher":{"@type":"Organization","name":"Tamir Bahar","logo":{"@type":"ImageObject","url":"https://tamir.dev/images/profilepic.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamir.dev/ accesskey=h title="Tamir Bahar (Alt + H)">Tamir Bahar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamir.dev/blogvent/ title=blogventüéÑ><span>blogventüéÑ</span></a></li><li><a href=https://tamir.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://tamir.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://tamir.dev/index.xml title=rss><span>rss</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="13"><g transform="scale(1)"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></g></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamir.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://tamir.dev/posts/>Posts</a></div><h1 class=post-title>Finalizing Mutexes</h1><div class=post-description>Looking into the release of Mutexes in GC languages</div><div class=post-meta><span title='2023-08-13 00:00:00 +0000 UTC'>Aug 13, 2023</span>&nbsp;¬∑&nbsp;Tamir Bahar</div></header><div class=post-content><p>Once I define a model for thinking, I find that it is good to keep running it over in your mind, and see how it applies to different situations.
To see if it holds for all cases, or if there are edge-cases that make it fall apart; or to see if there are interesting things to learn when applying it to real-world scenarios.</p><p>So, having <a href=../resource-management-01>talked about resources in my previous post</a>, I spend some time thinking about interesting edge-cases with resource-management in GC languages.
After a while, I thought about mutexes and locks.
They are an interesting example as they are usually made up of 2 separate resources.</p><h2 id=locks--mutexes><a href=#locks--mutexes>Locks & Mutexes<span hidden class=anchor aria-hidden=true href=#locks--mutexes>#</span></a></h2><p>When we think about locks, there is one obvious acquire-use-release cycle we think about.
We acquire the lock, use the resource it guards, then release the lock when we&rsquo;re done.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> thing<span style=color:#f92672>.</span>lock:   <span style=color:#75715e># Acquire the lock</span>
</span></span><span style=display:flex><span>	thing<span style=color:#f92672>.</span>modify() <span style=color:#75715e># Use the guarded resource</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Release the lock as we exit the scope</span>
</span></span></code></pre></td></tr></table></div></div><p>But in most cases, we have another resource - the lock itself.
On Windows, for example, a mutex can be creates using the <a href=https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa>CreateMutex</a> function.
That, in turn, returns a handle to the OS-level mutex.
When we&rsquo;re done using it, we need to call <a href=https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle>CloseHandle</a> to close the handle and have the OS release the mutex.
But&mldr; I never released a mutex in Python.
So what&rsquo;s going on?</p><h3 id=pythons-threadinglock><a href=#pythons-threadinglock>Python&rsquo;s <code>threading.Lock</code><span hidden class=anchor aria-hidden=true href=#pythons-threadinglock>#</span></a></h3><p>First, I wanted to make sure Python&rsquo;s <a href="https://docs.python.org/3/library/threading.html?highlight=threading%20lock#threading.Lock"><code>threading.Lock</code></a> is indeed backed by an OS-level mutex.
I could read the code, but there are simpler ways.</p><p><a href=https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer>Process Explorer</a> allows us to see the number of handles used by a process.
So if we create some locks, we should see the handle-count increasing.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Lock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Wait for input, so that we can open the process in ProcExp</span>
</span></span><span style=display:flex><span>input()
</span></span><span style=display:flex><span><span style=color:#75715e># Create 100 locks</span>
</span></span><span style=display:flex><span>locks <span style=color:#f92672>=</span> [Lock() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>)]
</span></span><span style=display:flex><span><span style=color:#75715e># Wait for input, so that we can see the increase</span>
</span></span><span style=display:flex><span>input()
</span></span></code></pre></td></tr></table></div></div><p>At first, we see that we have 92 handles:
<img src=handles-before.png alt="The Properties dialog in Process Explorer, showing the Performance tab, with a count of 92 handles.">
Then we press <code>Enter</code>, and see the number increase to 192:
<img src=handles-after.png alt="The same dialog, showing a count of 192 handles."></p><p>Which is what we expected.
This indicates that Python&rsquo;s <code>threading.Lock</code> is indeed backed by an OS mutex in Windows.
But&mldr; We never release those mutexes ourselves, so what is going on?</p><p>First, we need to make sure Python does not simply leak those resources.
By adding the following lines to our code:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Delete the locks, so that they can be released  </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>del</span> locks  
</span></span><span style=display:flex><span>input()
</span></span></code></pre></td></tr></table></div></div><p>We can see that after <code>del locks</code>, the handle count drops back down to 92.
So how does this happen?</p><h3 id=finalizers--the-__del__-method><a href=#finalizers--the-__del__-method>Finalizers & The <code>__del__</code> Method<span hidden class=anchor aria-hidden=true href=#finalizers--the-__del__-method>#</span></a></h3><p>To handle such cases, Python uses <strong>finalizers</strong>, implemented using <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__del__#object.__del__">the <code>__del__</code> method</a>.
The <code>__del__</code> method is called when an object is about to be destroyed.
As Python is a GC language, the language runtime owns the objects, and is responsible for destroying them <em>at its own time</em>.
This means that while it can be called immediately after we run <code>del locks</code>, it can also be called much later, or not at all.
Our only guarantee is that if and when the GC reclaims the memory of our object, it&rsquo;ll also call the <code>__del__</code> method to clean it up properly.</p><p>This is bad for unique-resources, and is why we use a context-manager to manage the lock itself.
But for counted-resources, like the OS handle representing the mutex itself - this is a good solution.
Even if the finalizer is not called before our process terminates, the OS itself will be sure to release those handles upon process termination.</p><h2 id=lessons-learned><a href=#lessons-learned>Lessons Learned<span hidden class=anchor aria-hidden=true href=#lessons-learned>#</span></a></h2><p>From this we learn a new lesson about Python, and our model.
For unique-resources, we want to use context-managers, to ensure release at the right time.
For counted-resources, we can use finalizers, and know that it&rsquo;s good enough.
In real code, we&rsquo;ll see that finalizers are usually used to wrap OS resources, and almost never user-defined-resources.</p><h2 id=other-languages><a href=#other-languages>Other Languages<span hidden class=anchor aria-hidden=true href=#other-languages>#</span></a></h2><p>Now that we know how Python handles counted-resources, we can have a look at some more languages.</p><h3 id=java--c><a href=#java--c>Java & C#<span hidden class=anchor aria-hidden=true href=#java--c>#</span></a></h3><p>In Java, things are roughly the same.
It&rsquo;s another object-oriented language, and it uses <a href=https://docs.oracle.com/javase/specs/jls/se20/html/jls-12.html#jls-12.6 title="Java finalizers">finalizers</a> for the same purposes.
<a href=https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers title="C# finalizers">C# behaves similarly</a>, being another object-oriented language.
I will venture a guess, and say that most GC object-oriented languages use finalizers.</p><p>But, not all GC languages are object-oriented.
Go, for example, is not.
As such, it is interesting to see how it tackles the same problem.</p><h3 id=go><a href=#go>Go<span hidden class=anchor aria-hidden=true href=#go>#</span></a></h3><p>Looking at <a href=https://go.dev/tour/concurrency/9>A Tour of Go</a>, we see that mutexes are used as simple structs.
There&rsquo;s no <code>NewMutex()</code> function nor <code>CloseMutex()</code>.
This is odd, as Go does not have finalizers.
But, looking at the implementation of the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.21.0:src/sync/mutex.go;l=34"><code>sync.Mutex</code></a> struct things become clear:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Go mutexes are not backed by OS mutexes.
This is probably because Go uses goroutines instead of OS-level threads, and manages its own concurrency.
Nice going, Go!</p><p>But what of other OS-level objects?
Go can make its own mutexes, but sockets, for example, <em>must</em> go through the OS.</p><h4 id=sockets><a href=#sockets>Sockets<span hidden class=anchor aria-hidden=true href=#sockets>#</span></a></h4><p>In Python, sockets are managed the same way mutexes are.
You can change the <code>threading.Lock</code> to <code>socket.socket</code> in the code we used above to see the effects.
In Go, however, they opted for a different solution.
Instead of having a &ldquo;socket&rdquo; object, <a href=https://pkg.go.dev/net#DialTCP title="Go's connection objects">they have &ldquo;connection&rdquo; objects</a>.
Those connection objects are <em>obviously</em> unique-resources, as one needs to close their connections (that&rsquo;s true in Python as well!).
So by modifying the API, they remain consistent and avoid leaks.</p><h2 id=final-words><a href=#final-words>Final Words<span hidden class=anchor aria-hidden=true href=#final-words>#</span></a></h2><p>By taking our model and applying to it different situations, we managed to learn some new things and reach new insights.</p><p>We learned about finalizers, and how they are used to manage counted-resources in GC languages.
And we learned about Go&rsquo;s scheduling, with their own mutexes; and their clever choices in the socket API to handle the lack of finalizers.</p><p>As we keep pushing our understanding of programming languages, and trying to apply it to more situations, I&rsquo;m sure we&rsquo;ll learn a lot more.</p></div><footer class=post-footer><ul class=post-tags></ul><div style=display:flex;justify-content:center class=discuss><a href=https://github.com/tmr232/tamir.dev/discussions/6 target=_blank rel="noopener noreferrer me" title="Discuss this post">Discuss this post<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="1em" style="margin-bottom:-.2em;margin-left:.2em"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tamir.dev/>Tamir Bahar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>