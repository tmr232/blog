<!doctype html><html lang=en>
<head>
<title>A Functional-Style State Machine in C++, Part 2 - tamir.dev</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Kiera: A Hugo theme for creative and technical writing.">
<meta name=author content="Tamir Bahar"><meta property="og:title" content="A Functional-Style State Machine in C++, Part 2">
<meta property="og:description" content="First, an apology. The first part of this post was published on May 26. It is now September. I had most of the code for this part done by then. But finalizing the code took some more effort.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.example.org/posts/a-functional-style-state-machine-in-cpp-part-2/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-09-04T00:00:00+00:00">
<meta property="article:modified_time" content="2017-09-04T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="A Functional-Style State Machine in C++, Part 2">
<meta name=twitter:description content="First, an apology. The first part of this post was published on May 26. It is now September. I had most of the code for this part done by then. But finalizing the code took some more effort.">
<meta name=generator content="Hugo 0.89.0">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://www.example.org/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://www.example.org/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://www.example.org/>tamir.dev</a>
</h1>
<ul id=social-media>
<li>
<a href=https://github.com/tmr232 title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/tmr232 title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://stackoverflow.com/tmr232 title=StackOverflow>
<i class="fab fa-stack-overflow fa-lg"></i>
</a>
</li>
<li>
<a href=https://dev.to/tmr232 title=devto>
<i class="fab fa-dev fa-lg"></i>
</a>
</li>
</ul>
<p><em>A Hugo theme for creative and technical writing</em></p>
</header>
<nav>
<ul>
</ul>
</nav>
<main>
<article>
<h1>A Functional-Style State Machine in C++, Part 2</h1>
<aside>
<ul>
<li>
<time class=post-date datetime=2017-09-04T00:00:00Z>Sep 4, 2017</time>
</li>
<li>10 minute read</li>
</ul>
</aside>
<p>First, an apology.
The first part of this post was published on May 26. It is now September. I had most of the code for this part done by then. But finalizing the code took some more effort. Once that was done, explaining took a while. There were quite a few things I had to learn myself first.
So now, months later, I present this humble offering to the Gods of C++ and template meta-programming.</p>
<hr>
<h2 id=generalizing>Generalizing</h2>
<p>In <a href=a-functional-style-state-machine-in-cpp>Part 1</a> we created our <code>State</code> or <code>SelfReturning</code> class (provided below for reference). It works, but as you can see - required modifications whenever we change the function arguments or return types.</p>
<p><a href=https://godbolt.org/g/1XqEhY>Compilation</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>SelfReturning, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);

    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{func} {};
    RetType <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) { <span style=color:#66d9ef>return</span> _func(ctx, evt); }

    FuncType _func;
};

<span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning;
</code></pre></div><p>The first thing we want to do is get rid of this requirement. First, function arguments.
<a href=https://godbolt.org/g/RNnzcc>Compilation</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Args</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>SelfReturning, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(Args... args);      <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span>
    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{func} {};
    RetType <span style=color:#a6e22e>operator</span>()(Args... args) {              <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> _func(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>(args)...);
    }

    FuncType _func;
};

<span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;
</code></pre></div><p>Here we use <a href=http://en.cppreference.com/w/cpp/language/parameter_pack>variadic templates</a> and <a href=http://en.cppreference.com/w/cpp/utility/forward>perfect forwarding</a> to forward all the function arguments directly to the target function. You can see that in (1) and (2) we use <code>Args...</code> and not the common <code>Args&&...</code>. This is because the types are defined by the class template and are not deduced on the function call.</p>
<p>With this behind us, we address the return type.
Here we come to another recursive issue. While the return type <code>std::pair&lt;SelfReturning, const Context></code> depends on our <code>SelfReturning</code> type, <code>SelfReturning</code> itself depends on the return type. This means that just passing in the return type will not work (much like our original return-type issue). To solve it, we use a <a href=http://en.cppreference.com/w/cpp/language/template_parameters>template-template parameter</a>.</p>
<p><a href=https://godbolt.org/g/DVgRPx>Compilation</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span>, <span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Args</span><span style=color:#f92672>&gt;</span> <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> Base<span style=color:#f92672>&lt;</span>SelfReturning<span style=color:#f92672>&gt;</span>; <span style=color:#75715e>//(2)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(Args... args);

    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{ func } {}
    RetType <span style=color:#a6e22e>operator</span>() (Args... args) {
        <span style=color:#66d9ef>return</span> _func(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>(args)...);
    }

    FuncType _func;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> PairWithCtx <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>; <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;
</code></pre></div><p>In (1), we pass in the template for the return type. In (2), we instantiate the type with our <code>SelfReturning</code> class. As we&rsquo;ve seen before, C++ allows this type of recursion, so we&rsquo;re safe. In (3) we define our return-type template to be a pair with a <code>const Context</code> as the second member.
Done.</p>
<p>But what if we want to only return the <code>SelfReturning</code> class? For that, we define a new template - an identity template.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>identity</span> {
	<span style=color:#66d9ef>using</span> type <span style=color:#f92672>=</span> T;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> identity_t <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> identity<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>type;
</code></pre></div><p>We define the <code>identity</code> struct to hold a type, and use the <code>identity_t</code> alias to access the type directly. This looks a bit odd, but C++ does not allow us to alias the template parameter directly. When isntatiating the <code>identity_t</code> template with a type, we get the safe type again. Using that, we can return <code>SelfReturning</code> directly.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>identity_t<span style=color:#f92672>&gt;</span>;
</code></pre></div><p>Personally, though, I hate having to write down the trivial cases explicitly. So let&rsquo;s use some dirty tricks.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> <span style=color:#f92672>=</span> identity_t, <span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Args</span><span style=color:#f92672>&gt;</span> <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> Base<span style=color:#f92672>&lt;</span>SelfReturning<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(Args... args);

    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{ func } {}
    RetType <span style=color:#a6e22e>operator</span>() (Args... args) {
        <span style=color:#66d9ef>return</span> _func(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>(args)...);
    }

    FuncType _func;

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>AltArgs</span><span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>using</span> WithArgs <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>Base, AltArgs...<span style=color:#f92672>&gt;</span>; <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>};
</code></pre></div><p>In (1) we simply add <code>identity_t</code> as the default argument for <code>Base</code>. This lets us write the most trivial case (return <code>SelfReturning</code>, take no arguments) as <code>SelfReturning&lt;></code>. Nice.
However, if we put anything into this set of template arguments, it will override <code>identity_t</code>. That&rsquo;s what the code at (2) is for. We set <code>WithArgs</code> to be <code>SelfReturning</code> with whatever <code>Base</code> parameter it already has, thus only accepting template parameters for the arguments. Now we can write all of the following with ease.
<a href=https://godbolt.org/g/xvtKaE>Compilation</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>using</span> Trivial <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;&gt;</span>;
<span style=color:#66d9ef>using</span> InPair <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>using</span> TrivialWithArgs <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;&gt;::</span>WithArgs<span style=color:#f92672>&lt;</span>Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;
<span style=color:#66d9ef>using</span> InPairWithArgs <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx<span style=color:#f92672>&gt;::</span>WithArgs<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;
<span style=color:#75715e>// Or alternatively
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> InPairWithArgs2 <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;
</code></pre></div><p>In <a href=https://www.example.org/posts/a-functional-style-state-machine-in-cpp>Part 1</a> I promised generalizing the <code>SelfReturning</code> class and getting some compile time guarantees. We&rsquo;ve accomplished our generalization goal, so it&rsquo;s time to get some safety in place.</p>
<h2 id=increasing-safety>Increasing Safety</h2>
<p>While our use of the <code>switch</code> statement to discern different events is nice and concise, it is also somewhat error prone. It is easy to miss a case (though that can be prevented using compiler errors) or accidentally mistake one event for another. The latter is especially true if we want to pass information along with our event notification.
One easy way to avoid those mistakes is to resolve the choice using function overloading instead of switch statements. Consider the following</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EventType</span> {A, B};

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Switch</span>(EventType evt) {
    <span style=color:#66d9ef>switch</span>(evt) {
        <span style=color:#66d9ef>case</span> EventType<span style=color:#f92672>::</span>A:
            puts(<span style=color:#e6db74>&#34;A&#34;</span>);
            <span style=color:#66d9ef>return</span>;
        <span style=color:#66d9ef>case</span> EventType<span style=color:#f92672>::</span>B:
            puts(<span style=color:#e6db74>&#34;B&#34;</span>);
            <span style=color:#66d9ef>return</span>;
    }
}

<span style=color:#75715e>// (2)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {};

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Overload</span>(EventA) { puts(<span style=color:#e6db74>&#34;A&#34;</span>); }
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Overload</span>(EventB) { puts(<span style=color:#e6db74>&#34;B&#34;</span>); }
</code></pre></div><p>In (1) we use a <code>switch</code> to discern the event type. It is easy to forget a <code>return</code> or a <code>break</code>. If we passed more data along, the signature for <code>Switch</code> would likely change to <code>void Switch(EventType evt, void* data)</code>. That&rsquo;s definitely bad.
In (2), we cannot mistake the types, and data can easily be passed inside the event structs. Sadly, the events are not different types, and C++ does not allow for heterogeneous containers. Or does it?</p>
<p>Enter C++17&rsquo;s ✨<code>std::variant</code>✨.</p>
<p>What is <code>std::variant</code>, you ask? Well, it is a <code>union</code>. A <em>safe</em> <code>union</code>! Safe meaning that you can only get a value from it if it really is there. No more type confusion; no more casting <code>void</code> pointers. But how do we get the values out of <code>std::variant</code>? Using <code>std::visit</code>, of course!
<a href=https://godbolt.org/g/EfBahi>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/95c37042037573ca>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {}; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventHandler</span> {  <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>() (EventA) { puts(<span style=color:#e6db74>&#34;A&#34;</span>); }
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>() (EventB) { puts(<span style=color:#e6db74>&#34;B&#34;</span>); }
};

<span style=color:#66d9ef>using</span> event_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span>EventA, EventB<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>event_t<span style=color:#f92672>&gt;</span> events <span style=color:#f92672>=</span> {EventA{}, EventB{}};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> event : events) {
        std<span style=color:#f92672>::</span>visit(EventHandler{}, event); <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define our new event types. This time they are different types, not just different values. In (2) we define our event handler. All we need is an function overload for every possible type, and a struct with multiple <code>operator()</code> methods is an easy way to do it. Now all that is left to do is call <code>std::visit</code> with our handler and an event. If we forget to handle an event type - the code <a href=https://godbolt.org/g/Lzu3xV>does not compile!</a> This way, we <em>know</em> that we always handle all event types, and never mix them up.</p>
<p>Now, if you liked the previous part, you probably don&rsquo;t like writing a different handler class for every function. It completely ruins the locality of the code. But, we are using C++17, aren&rsquo;t we?
<a href=https://godbolt.org/g/bqsqE9>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/31074c40d4c9654d>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>overloaded</span> <span style=color:#f92672>:</span> Ts... { <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...; }; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> overloaded(Ts...) <span style=color:#f92672>-&gt;</span> overloaded<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {};

<span style=color:#66d9ef>using</span> event_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span>EventA, EventB<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>event_t<span style=color:#f92672>&gt;</span> events <span style=color:#f92672>=</span> {EventA{}, EventB{}};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> event : events) {
        std<span style=color:#f92672>::</span>visit(overloaded {         <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>            [] (EventA) { puts(<span style=color:#e6db74>&#34;A&#34;</span>); },
            [] (EventB) { puts(<span style=color:#e6db74>&#34;B&#34;</span>); }
        }, event);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>If you&rsquo;re not familiar with C++17, there may be a lot to take in here. In (1) we define a class that takes multiple lambdas and overloads them. In (2) we instantiate that class to inline our event handling functions.
The full explanation to this code is a bit long, so I wrote <a href=https://www.example.org/posts/that-overloaded-trick-overloading-lambdas-in-cpp17>another post</a> to explain it.</p>
<p>Applied to the state-machine, it will look like this:
<a href=https://godbolt.org/g/4VNxEM>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/3bfd9a9220c60cb4>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tuple&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>overloaded</span> <span style=color:#f92672>:</span> Ts... { <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...; };
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> overloaded(Ts...) <span style=color:#f92672>-&gt;</span> overloaded<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {};

<span style=color:#66d9ef>using</span> Event <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span>EventA, EventB<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Context</span> {
    Context <span style=color:#a6e22e>Inc</span>() <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>return</span> Context{counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>};
    }
    <span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>identity</span> {
	<span style=color:#66d9ef>using</span> type <span style=color:#f92672>=</span> T;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> identity_t <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> identity<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>type;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> <span style=color:#f92672>=</span> identity_t, <span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Args</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> Base<span style=color:#f92672>&lt;</span>SelfReturning<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(Args... args);

    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{ func } {}
    RetType <span style=color:#a6e22e>operator</span>() (Args... args) {
        <span style=color:#66d9ef>return</span> _func(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>(args)...);
    }

    FuncType _func;

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>AltArgs</span><span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>using</span> WithArgs <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>Base, AltArgs...<span style=color:#f92672>&gt;</span>;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> PairWithCtx <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx<span style=color:#f92672>&gt;::</span>WithArgs<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);
State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State A, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx); },
        [<span style=color:#f92672>&amp;</span>] (EventB) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx.Inc()); }
    }, evt);
}

State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State B, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx.Inc()); },
        [<span style=color:#f92672>&amp;</span>] (EventB) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx); }
    }, evt);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    State state <span style=color:#f92672>=</span> A;
    Context ctx{};
    Event events[] <span style=color:#f92672>=</span> {EventB{}, EventA{}, EventB{}, EventA{}, };

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> evt : events) {
        std<span style=color:#f92672>::</span>tie(state, ctx) <span style=color:#f92672>=</span> state(ctx, evt);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>As you can see, the change is minimal.</p>
<h2 id=passing-in-data>Passing In Data</h2>
<p>With that, it is time to address an issue I completely neglected in Part 1.
Passing in data.</p>
<p>Our current state-machine model is based on the idea that the events themselves are the only information the states need. This is naive. In many real-life scenarios, events carry data with them. Now, with <code>std::variant</code>, we can puts data into the different event types. All we need to do is add data-members to our event structs. We define our new, data-carrying events as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> msg{<span style=color:#66d9ef>nullptr</span>};
};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {
    <span style=color:#66d9ef>int</span> number{<span style=color:#ae81ff>0</span>};
};
</code></pre></div><p>Nothing else needs to change. And now, in the state functions, we can easily access the event data:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State A, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA e) { 
            <span style=color:#66d9ef>if</span> (e.msg <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
                printf(<span style=color:#e6db74>&#34;A message = </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>, e.msg);
            } <span style=color:#66d9ef>else</span> {
                puts(<span style=color:#e6db74>&#34;A message = nullptr&#34;</span>);
            }
            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx); 
        },
        [<span style=color:#f92672>&amp;</span>] (EventB) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx.Inc()); }
    }, evt);
}

State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State B, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA e) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx.Inc()); },
        [<span style=color:#f92672>&amp;</span>] (EventB e) { 
            printf(<span style=color:#e6db74>&#34;B number = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, e.number);
            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx); 
        }
    }, evt);
}
</code></pre></div><p>Et voilà.</p>
<p>Putting everything together now, we get the following code:</p>
<p><a href=https://godbolt.org/g/rR5udQ>Compilation</a>,<a href=http://coliru.stacked-crooked.com/a/273170beeb72c9a7>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tuple&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>overloaded</span> <span style=color:#f92672>:</span> Ts... { <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...; };
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> overloaded(Ts...) <span style=color:#f92672>-&gt;</span> overloaded<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventA</span> {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> msg{<span style=color:#66d9ef>nullptr</span>};
};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>EventB</span> {
    <span style=color:#66d9ef>int</span> number{<span style=color:#ae81ff>0</span>};
};

<span style=color:#66d9ef>using</span> Event <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span>EventA, EventB<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Context</span> {
    Context <span style=color:#a6e22e>Inc</span>() <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>return</span> Context{counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>};
    }
    <span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>identity</span> {
	<span style=color:#66d9ef>using</span> type <span style=color:#f92672>=</span> T;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> identity_t <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> identity<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>type;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> <span style=color:#f92672>=</span> identity_t, <span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Args</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> Base<span style=color:#f92672>&lt;</span>SelfReturning<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(Args... args);

    SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{ func } {}
    RetType <span style=color:#a6e22e>operator</span>() (Args... args) {
        <span style=color:#66d9ef>return</span> _func(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>(args)...);
    }

    FuncType _func;

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>AltArgs</span><span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>using</span> WithArgs <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>Base, AltArgs...<span style=color:#f92672>&gt;</span>;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>using</span> PairWithCtx <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>;

<span style=color:#66d9ef>using</span> State <span style=color:#f92672>=</span> SelfReturning<span style=color:#f92672>&lt;</span>PairWithCtx<span style=color:#f92672>&gt;::</span>WithArgs<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event<span style=color:#f92672>&gt;</span>;

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);
State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State A, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA e) { 
            <span style=color:#66d9ef>if</span> (e.msg <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
                printf(<span style=color:#e6db74>&#34;A message = </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>, e.msg);
            } <span style=color:#66d9ef>else</span> {
                puts(<span style=color:#e6db74>&#34;A message = nullptr&#34;</span>);
            }
            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx); 
        },
        [<span style=color:#f92672>&amp;</span>] (EventB) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx.Inc()); }
    }, evt);
}

State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State B, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>visit(overloaded{
        [<span style=color:#f92672>&amp;</span>] (EventA e) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(A, ctx.Inc()); },
        [<span style=color:#f92672>&amp;</span>] (EventB e) { 
            printf(<span style=color:#e6db74>&#34;B number = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, e.number);
            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>make_pair</span>(B, ctx); 
        }
    }, evt);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    State state <span style=color:#f92672>=</span> A;
    Context ctx{};
    Event events[] <span style=color:#f92672>=</span> {EventB{}, EventA{}, EventB{}, EventB{<span style=color:#ae81ff>10</span>}, EventA{}, EventA{<span style=color:#e6db74>&#34;Hello, world!&#34;</span>}};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> evt : events) {
        std<span style=color:#f92672>::</span>tie(state, ctx) <span style=color:#f92672>=</span> state(ctx, evt);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h2 id=summary>Summary</h2>
<p>As promised, we have used some dark template magic to achieve:</p>
<ol>
<li>A nice generalization of <code>SelfReturning</code>, allowing customization of both return types and argument types;</li>
<li>Better compile-time safety by replacing the <code>switch</code> statement with overload resolution;</li>
<li>Passing data along with the events.</li>
<li>Hopefully, a lot of fun along the way.</li>
</ol>
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://www.example.org/posts/that-overloaded-trick-overloading-lambdas-in-cpp17/><i class="fa fa-chevron-circle-left"></i> That `overloaded` Trick: Overloading Lambdas in C++17</a>
</li>
<li>
<a href=https://www.example.org/posts/types-of-loops/>Types of Loops <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>Copyright © 2021 - Tamir Bahar |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://www.example.org/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://www.example.org/js/scripts.js></script>
</body>
</html>