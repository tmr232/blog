<!doctype html><html lang=en>
<head>
<title>A Functional-Style State Machine in C++ - tamir.dev</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="The HTML5 Herald">
<meta name=author content="Tamir Bahar"><meta property="og:title" content="A Functional-Style State Machine in C++">
<meta property="og:description" content="It turns out that C++'s type-system does not allow for recursive types. This is annoying. There is no reason why a function should not be able to return itself.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.tamir.dev/posts/a-functional-style-state-machine-in-cpp/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-05-26T00:00:00+00:00">
<meta property="article:modified_time" content="2017-05-26T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="A Functional-Style State Machine in C++">
<meta name=twitter:description content="It turns out that C++'s type-system does not allow for recursive types. This is annoying. There is no reason why a function should not be able to return itself.">
<meta name=generator content="Hugo 0.89.0">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://blog.tamir.dev/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://blog.tamir.dev/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://blog.tamir.dev/>tamir.dev</a>
</h1>
<ul id=social-media>
<li>
<a href=https://github.com/tmr232 title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/tmr232 title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://stackoverflow.com/users/3337893/tmr232 title=StackOverflow>
<i class="fab fa-stack-overflow fa-lg"></i>
</a>
</li>
<li>
<a href=https://dev.to/tmr232 title=devto>
<i class="fab fa-dev fa-lg"></i>
</a>
</li>
</ul>
</header>
<nav>
<ul>
</ul>
</nav>
<main>
<article>
<h1>A Functional-Style State Machine in C++</h1>
<aside>
<ul>
<li>
<time class=post-date datetime=2017-05-26T00:00:00Z>May 26, 2017</time>
</li>
<li>6 minute read</li>
</ul>
</aside>
<p>If you go to any of your colleagues now and ask them, <em>&ldquo;can a function in C++ return itself?"</em> they will probably give you the wrong answer.
Now ask them what the return type of the function is going to be. Here, let me help you:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>using</span> SelfReturning <span style=color:#f92672>=</span> SelfReturning (<span style=color:#f92672>*</span>)();

SelfReturning <span style=color:#a6e22e>A</span>() { <span style=color:#66d9ef>return</span> A; }
</code></pre></div><p>Great!
But it doesn&rsquo;t compile. and neither does</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>A</span>() { <span style=color:#66d9ef>return</span> A; }
</code></pre></div><p>It turns out that C++&rsquo;s type-system does not allow for recursive types. This is annoying. There is no reason why a function should not be able to return itself. It is even more annoying given that object methods can return the objects that hold them:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> {
    A <span style=color:#a6e22e>operator</span>()() { <span style=color:#66d9ef>return</span> A(); }
};
</code></pre></div><p>This code works. And for obvious reasons. Object methods are not a part of the object. They do not affect the object size or its construction. They are just a syntactic utility. There is no type-system recursion going on here.</p>
<p>With functions there is obvious type-recursion. But if you look at the work the compiler actually has to do - it seems absurd. A function is never constructed, it just is. It is not allocated. The function&rsquo;s signature changes nothing about the type.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>A</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(A);  <span style=color:#75715e>// Same as C&#39;s `(void*)A`
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() { 
    <span style=color:#66d9ef>auto</span> a <span style=color:#f92672>=</span> A;

    <span style=color:#66d9ef>while</span> (true) {
        <span style=color:#75715e>// Cast back to function pointer
</span><span style=color:#75715e></span>        a <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>)()<span style=color:#f92672>&gt;</span>(A());
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>See? No missing information. The compiler has all the knowledge it needs, but the type-system still prevents us from writing our code (or, in this case, from writing it in a type-safe manner). We can do better.</p>
<p>We already know that objects can be used to break type recursion. Let&rsquo;s see if we can use them here without creating so much boiler-plate code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelfReturning</span> {
	<span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> SelfReturning(<span style=color:#f92672>*</span>)(); <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span>	
	SelfReturning(FuncType func) <span style=color:#f92672>:</span> _func{func} {} <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>	SelfReturning <span style=color:#a6e22e>operator</span>() () { <span style=color:#66d9ef>return</span> _func(); } <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
		FuncType _func;
};
</code></pre></div><p>The answer is yes. We <em>can</em>. Just substitute this class for the failed type definition of the first example and everything works as advertised. But how does it work?
To break the type-recursion, we create a proxy object. Its sole purpose is to hold a function pointer and call it.
Line <strong>(1)</strong> defines the function type that we expect to hold. Note that there is no direct recursion there. <strong>(2)</strong> is the constructor, taking the function pointer and storing it. <strong>(3)</strong> is where we forward the call to the function pointer. Note that here, too there is no type recursion as the type of the class is distinct from the type of its <code>operator()</code> function.
As a bonus, this compiles identical to the <code>reinterpret_cast&lt;void*></code> version in both Clang and GCC when using <code>-O3</code> (see <a href=https://godbolt.org/g/QDz9Oc>here</a> and <a href=https://godbolt.org/g/ln0AZG>here</a>), and at the same time maintaining type-safety. Zero-cost abstraction at work.</p>
<p>But why is that interesting? What are the use-cases?</p>
<p>Well, during the last few months, I&rsquo;ve routinely consumed one programming-related talk per day. I find it a great way to expand my knowledge, and far easier to do than reading an article every day.</p>
<p>Last week, while working on some minor state-machine, I came across <a href=https://youtu.be/nrVIlhtoE3Y>Declarative Thinking, Declarative Practice</a> by <a href=https://twitter.com/KevlinHenney>Kevlin Henney</a>. Upon seeing <a href="https://youtu.be/nrVIlhtoE3Y?t=1h17m3s">this slide</a>:</p>
<p><img src=https://blog.tamir.dev/images/state-machine-kevlin-henney.png alt></p>
<p>I thought - bare functions instead of the State design pattern? I have to try that! So I went ahead and wrote my code, iterating through the steps described above.
At a quick glance, the functor solution may seem satisfying. But in effect functors, unlike functions, have different types and cannot be assigned to the same variable. To bridge the gap, we use an abstract base-class and polymorphism. Once we do that, we are forced to use pointers to hold the states. I use <code>std::unique_ptr</code> as I don&rsquo;t want to manage the memory myself.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IState</span> {
    <span style=color:#66d9ef>virtual</span> std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>operator</span>()() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>IState() {};
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> IState { std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>operator</span>()(); };
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> IState { std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>operator</span>()(); };

std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> A<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()() { <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>B<span style=color:#f92672>&gt;</span>(); }
std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> B<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()() { <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>A<span style=color:#f92672>&gt;</span>(); }

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>IState<span style=color:#f92672>&gt;</span> state <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>A<span style=color:#f92672>&gt;</span>();

    <span style=color:#66d9ef>while</span> (true) { state <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>state)(); }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>The proxy-object trick, however, has no such overhead. We know that we are using objects, but the code does not show it. The compiled version is far simpler as well (see <a href=https://godbolt.org/g/RoIt28>here</a> and <a href=https://godbolt.org/g/lXJpb8>here</a>).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> State(<span style=color:#f92672>*</span>)();
    State(FuncType func) <span style=color:#f92672>:</span> _func{func} {};
    State <span style=color:#a6e22e>operator</span>()() { <span style=color:#66d9ef>return</span> _func(); }
    FuncType _func;
};

State <span style=color:#a6e22e>A</span>();
State <span style=color:#a6e22e>B</span>();

State <span style=color:#a6e22e>A</span>() { <span style=color:#66d9ef>return</span> B; }
State <span style=color:#a6e22e>B</span>() { <span style=color:#66d9ef>return</span> A; }

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    State state <span style=color:#f92672>=</span> A;

    <span style=color:#66d9ef>while</span> (true) { state <span style=color:#f92672>=</span> state(); }
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Enhancing it a bit, to handle events and operate on a context, we still maintain very simple, straight-forward code. For the purpose of this example, <code>abort()</code> and <code>printf()</code> are used instead of <code>throw std::runtime_error</code> and <code>std::cout</code> because the compiled output is easier to read. See compilation <a href=https://godbolt.org/g/LcAsfU>here</a> and execution <a href=http://coliru.stacked-crooked.com/a/64b54b8c5282ac23>here</a>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Event</span>{ A, B, };

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Context</span> {
    <span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> State(<span style=color:#f92672>*</span>)(Context<span style=color:#f92672>&amp;</span>, Event);
    State(FuncType func) <span style=color:#f92672>:</span> _func{func} {};
    State <span style=color:#a6e22e>operator</span>()(Context<span style=color:#f92672>&amp;</span> ctx, Event evt) { <span style=color:#66d9ef>return</span> _func(ctx, evt); }
    FuncType _func;
};

State <span style=color:#a6e22e>A</span>(Context<span style=color:#f92672>&amp;</span>, Event);
State <span style=color:#a6e22e>B</span>(Context<span style=color:#f92672>&amp;</span>, Event);

State <span style=color:#a6e22e>A</span>(Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State A, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#f92672>++</span>ctx.counter;
    <span style=color:#66d9ef>switch</span> (evt) {
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>A :
            <span style=color:#66d9ef>return</span> A;
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>B :
            <span style=color:#66d9ef>return</span> B;
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
            abort();
    }
}

State <span style=color:#a6e22e>B</span>(Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State B, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#f92672>++</span>ctx.counter;
    <span style=color:#66d9ef>switch</span> (evt) {
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>A :
            <span style=color:#66d9ef>return</span> A;
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>B :
            <span style=color:#66d9ef>return</span> B;
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
            abort();
    }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    State state <span style=color:#f92672>=</span> A;
    Context ctx{};
    Event events[] <span style=color:#f92672>=</span> {Event<span style=color:#f92672>::</span>B, Event<span style=color:#f92672>::</span>A, Event<span style=color:#f92672>::</span>B, Event<span style=color:#f92672>::</span>A, };

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> evt : events) {
        state <span style=color:#f92672>=</span> state(ctx, evt);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>For those keen on functional programming, we can even pass in a const reference to the context, and return a new context along with the new state. <a href=https://godbolt.org/g/Dd1XKr>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/e7ef3a7ab08e0e88>execution</a>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tuple&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Event</span>{ A, B, };

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Context</span> {
    Context <span style=color:#a6e22e>Inc</span>() <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>return</span> Context{counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>};
    }
    <span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
    <span style=color:#66d9ef>using</span> RetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>State, <span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&gt;</span>;
    <span style=color:#66d9ef>using</span> FuncType <span style=color:#f92672>=</span> RetType(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);
    State(FuncType func) <span style=color:#f92672>:</span> _func{func} {};
    RetType <span style=color:#a6e22e>operator</span>()(Context<span style=color:#f92672>&amp;</span> ctx, Event evt) { <span style=color:#66d9ef>return</span> _func(ctx, evt); }
    FuncType _func;
};

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);
State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span>, Event);

State<span style=color:#f92672>::</span>RetType A(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State A, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>switch</span> (evt) {
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>A :
            <span style=color:#66d9ef>return</span> {A, ctx};
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>B :
            <span style=color:#66d9ef>return</span> {B, ctx.Inc()};
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
            abort();
    }
}

State<span style=color:#f92672>::</span>RetType B(<span style=color:#66d9ef>const</span> Context<span style=color:#f92672>&amp;</span> ctx, Event evt) {
    printf(<span style=color:#e6db74>&#34;State B, counter = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ctx.counter);
    <span style=color:#66d9ef>switch</span> (evt) {
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>A :
            <span style=color:#66d9ef>return</span> {A, ctx.Inc()};
        <span style=color:#66d9ef>case</span> Event<span style=color:#f92672>::</span>B :
            <span style=color:#66d9ef>return</span> {B, ctx};
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
            abort();
    }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    State state <span style=color:#f92672>=</span> A;
    Context ctx{};
    Event events[] <span style=color:#f92672>=</span> {Event<span style=color:#f92672>::</span>B, Event<span style=color:#f92672>::</span>A, Event<span style=color:#f92672>::</span>B, Event<span style=color:#f92672>::</span>A, };

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> evt : events) {
        std<span style=color:#f92672>::</span>tie(state, ctx) <span style=color:#f92672>=</span> state(ctx, evt);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><p>And that&rsquo;s it. We have a state machine based on pure-, bare-functions, in C++. It has a nice, simple look to it and as we&rsquo;ve seen, compiles into far simpler code than the alternatives. On the way, we&rsquo;ve also learned a bit about C++&rsquo;s type system and how to use objects to overcome its limitations.
In the <a href=https://blog.tamir.dev/posts/a-functional-style-state-machine-in-cpp-part-2>next post</a> (<del><em>soon to be populated</em></del> <em>now online!</em>) I will show some exciting (read: never use in production) dark template magic to both generalize the <code>State</code> object and to get some compile-time guarantees. Stay tuned!</p>
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://blog.tamir.dev/posts/the-windows-cli-sucks-and-thats-good/><i class="fa fa-chevron-circle-left"></i> The Windows CLI sucks, and that's good.</a>
</li>
<li>
<a href=https://blog.tamir.dev/posts/that-overloaded-trick-overloading-lambdas-in-cpp17/>That `overloaded` Trick: Overloading Lambdas in C++17 <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>Copyright © 2021 - Tamir Bahar |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://blog.tamir.dev/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://blog.tamir.dev/js/scripts.js></script>
</body>
</html>