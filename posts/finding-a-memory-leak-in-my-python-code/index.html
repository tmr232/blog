<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Finding a memory-leak in my Python code | Tamir Bahar</title><meta name=keywords content><meta name=description content="Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.
Step 1 - Reproduction As with every bug, before you can reliably fix it, you must reproduce it."><meta name=author content="Tamir Bahar"><link rel=canonical href=https://tamir.dev/posts/finding-a-memory-leak-in-my-python-code/><link crossorigin=anonymous href=/assets/css/stylesheet.947e59c82c22a5677e549390ae88cc5edb5379cfdf5e7014c0320119c8985496.css integrity="sha256-lH5ZyCwipWd+VJOQrojMXttTec/fXnAUwDIBGciYVJY=" rel="preload stylesheet" as=style><link rel=icon href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=16x16 href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=32x32 href=https://tamir.dev/images/profilepic.jpg><link rel=apple-touch-icon href=https://tamir.dev/images/profilepic.jpg><link rel=mask-icon href=https://tamir.dev/images/profilepic.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Finding a memory-leak in my Python code"><meta property="og:description" content="Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.
Step 1 - Reproduction As with every bug, before you can reliably fix it, you must reproduce it."><meta property="og:type" content="article"><meta property="og:url" content="https://tamir.dev/posts/finding-a-memory-leak-in-my-python-code/"><meta property="og:image" content="https://tamir.dev/images/profilepic.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-30T00:00:00+00:00"><meta property="og:site_name" content="Tamir Bahar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tamir.dev/images/profilepic.jpg"><meta name=twitter:title content="Finding a memory-leak in my Python code"><meta name=twitter:description content="Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.
Step 1 - Reproduction As with every bug, before you can reliably fix it, you must reproduce it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamir.dev/posts/"},{"@type":"ListItem","position":2,"name":"Finding a memory-leak in my Python code","item":"https://tamir.dev/posts/finding-a-memory-leak-in-my-python-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Finding a memory-leak in my Python code","name":"Finding a memory-leak in my Python code","description":"Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.\nStep 1 - Reproduction As with every bug, before you can reliably fix it, you must reproduce it.","keywords":[],"articleBody":"Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.\nStep 1 - Reproduction As with every bug, before you can reliably fix it, you must reproduce it.\nNow, while I had a reliable reproduction (after all, the process had regular dates with the OOM Killer), 3 days isnâ€™t the best cycle time when you wanna solve a bug. So into the code we go.\nThe main idea is to start with the main loop, and try to narrow down the code that is must run for the leak to manifest. The process involves some educated guesses (where are the likely memory and allocation hogs in your process? What parts are likely to leak? Do you have any code that requires cleanup?), waiting, frustration, and tools.\ntracemalloc While each developer and codebase have their own unique guesses and frustrations, good tooling applies more widely. For this part, I used Pythonâ€™s tracemalloc module.\nAmong other things, tracemalloc allows tracking memory usage between 2 points in your code in a very low-overhead manner.\n1 2 3 4 5 tracemalloc.start() # Start the memory trace code_suspected_of_leak() current, peak = tracemalloc.get_traced_memory() # Get memory stats After running this code, peak will hold the peak-memory-usage during the trace period, and current will hold the difference from the start of the trace to the current state. You should expect current to be non-zero. But if it goes too high - your code is probably leaking.\nBy placing such traces around suspect pieces of our code, we can find which parts are leaking. Just remember - only do this with functions that are expected to retain no state. If a function mutates an external object, or is a member function, it is very to exhibit changes in memory usage.\nStep 2 - Triage Once we have a reproduction (that hopefully takes a relatively short amount of time), we want to find the leaking code. We can try and keep narrowing our measured code down until we find the relevant line, but the deeper we go, the harder it is to separate the leak from normal execution.\nSo at this point, weâ€™d like to look into the allocated memory, and see which objects are there when they shouldnâ€™t be.\npympler For inspecting the objects in a Python process, I recommend using pympler.\nPympler is a development tool to measure, monitor and analyze the memory behavior of Python objects in a running Python application.\nWeâ€™re going to use it to do 2 things.\nInspecting Allocated Objects First, weâ€™re going to use pympler to show us which objects were allocated during our repro \u0026 are still allocated.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from pympler import tracker, muppy, refbrowser from functools import lru_cache # Naive code to trigger a leak class Value: def __init__(self, value): self._value = value def __repr__(self): return f\"Value({self._value})\" @lru_cache(maxsize=100) def get_value(value): return Value(value) def code_suspected_of_leak(): for x in range(10): print(get_value(x)) # Measuring code def main(): tr = tracker.SummaryTracker() code_suspected_of_leak() tr.print_diff() Once we run this, we get a nice table showing us a summary of objects created and destroyed:\n1 2 3 4 5 6 7 8 9 10 11 types | # objects | total size ======================= | =========== | ============ list | 4892 | 500.59 KB str | 4887 | 341.45 KB int | 1053 | 28.79 KB dict | 13 | 1.90 KB __main__.Value | 10 | 640 B function (store_info) | 1 | 144 B cell | 2 | 112 B weakref | 1 | 88 B tuple | -8 | -680 B As you can see - there are quite a few primitive objects generated, and also some __main__.Value objects. In my experience, primitives are harder to track, as they lack meaning in the code. Your own types, however, are usually only used in certain parts of the codebase, making them easier to make sense of.\nNow that we see that we have 10 new Value objects, it is time to figure out whoâ€™s holding them in memory.\n1 2 3 4 5 6 7 def output_function(o): return str(type(o)) all_objects = muppy.get_objects() root = muppy.filter(all_objects, Value)[0] cb = refbrowser.ConsoleBrowser(root, maxdepth=2, str_func=output_function) cb.print_tree() Thisâ€™ll print the following:\n1 2 3 ","wordCount":"874","inLanguage":"en","datePublished":"2021-01-30T00:00:00Z","dateModified":"2021-01-30T00:00:00Z","author":{"@type":"Person","name":"Tamir Bahar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamir.dev/posts/finding-a-memory-leak-in-my-python-code/"},"publisher":{"@type":"Organization","name":"Tamir Bahar","logo":{"@type":"ImageObject","url":"https://tamir.dev/images/profilepic.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamir.dev/ accesskey=h title="Tamir Bahar (Alt + H)">Tamir Bahar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamir.dev/blogvent/ title=blogventðŸŽ„><span>blogventðŸŽ„</span></a></li><li><a href=https://tamir.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://tamir.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://tamir.dev/index.xml title=rss><span>rss</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="13"><g transform="scale(1)"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></g></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamir.dev/>Home</a>&nbsp;Â»&nbsp;<a href=https://tamir.dev/posts/>Posts</a></div><h1 class=post-title>Finding a memory-leak in my Python code</h1><div class=post-meta><span title='2021-01-30 00:00:00 +0000 UTC'>Jan 30, 2021</span>&nbsp;Â·&nbsp;Tamir Bahar</div></header><div class=post-content><p>Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.</p><h2 id=step-1---reproduction><a href=#step-1---reproduction>Step 1 - Reproduction<span hidden class=anchor aria-hidden=true href=#step-1---reproduction>#</span></a></h2><p>As with every bug, before you can reliably fix it, you must reproduce it.</p><p>Now, while I had a reliable reproduction (after all, the process had regular dates with the OOM Killer), 3 days isn&rsquo;t the best cycle time when you wanna solve a bug. So into the code we go.</p><p>The main idea is to start with the main loop, and try to narrow down the code that is must run for the leak to manifest. The process involves some educated guesses (where are the likely memory and allocation hogs in your process? What parts are likely to leak? Do you have any code that requires cleanup?), waiting, frustration, and tools.</p><h3 id=tracemalloc><a href=#tracemalloc>tracemalloc<span hidden class=anchor aria-hidden=true href=#tracemalloc>#</span></a></h3><p>While each developer and codebase have their own unique guesses and frustrations, good tooling applies more widely. For this part, I used Python&rsquo;s <a href=https://docs.python.org/3/library/tracemalloc.html>tracemalloc module</a>.</p><p>Among other things, <code>tracemalloc</code> allows tracking memory usage between 2 points in your code in a very low-overhead manner.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>tracemalloc<span style=color:#f92672>.</span>start() <span style=color:#75715e># Start the memory trace</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>code_suspected_of_leak()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>current, peak <span style=color:#f92672>=</span> tracemalloc<span style=color:#f92672>.</span>get_traced_memory() <span style=color:#75715e># Get memory stats</span>
</span></span></code></pre></td></tr></table></div></div><p>After running this code, <code>peak</code> will hold the peak-memory-usage during the trace period, and <code>current</code> will hold the difference from the start of the trace to the current state. You should expect <code>current</code> to be non-zero. But if it goes too high - your code is probably leaking.</p><p>By placing such traces around suspect pieces of our code, we can find which parts are leaking. Just remember - only do this with functions that are expected to retain no state. If a function mutates an external object, or is a member function, it is very to exhibit changes in memory usage.</p><h2 id=step-2---triage><a href=#step-2---triage>Step 2 - Triage<span hidden class=anchor aria-hidden=true href=#step-2---triage>#</span></a></h2><p>Once we have a reproduction (that hopefully takes a relatively short amount of time), we want to find the leaking code. We can try and keep narrowing our measured code down until we find the relevant line, but the deeper we go, the harder it is to separate the leak from normal execution.</p><p>So at this point, we&rsquo;d like to look into the allocated memory, and see which objects are there when they shouldn&rsquo;t be.</p><h3 id=pympler><a href=#pympler>pympler<span hidden class=anchor aria-hidden=true href=#pympler>#</span></a></h3><p>For inspecting the objects in a Python process, I recommend using <a href=https://pympler.readthedocs.io/en/latest/><code>pympler</code></a>.</p><blockquote><p>Pympler is a development tool to measure, monitor and analyze the memory behavior of Python objects in a running Python application.</p></blockquote><p>We&rsquo;re going to use it to do 2 things.</p><h4 id=inspecting-allocated-objects><a href=#inspecting-allocated-objects>Inspecting Allocated Objects<span hidden class=anchor aria-hidden=true href=#inspecting-allocated-objects>#</span></a></h4><p>First, we&rsquo;re going to use <code>pympler</code> to show us which objects were allocated during our repro & are still allocated.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pympler <span style=color:#f92672>import</span> tracker, muppy, refbrowser
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> lru_cache
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Naive code to trigger a leak</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Value</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, value):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_value <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Value(</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>_value<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@lru_cache</span>(maxsize<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_value</span>(value):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Value(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>code_suspected_of_leak</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        print(get_value(x))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Measuring code</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    tr <span style=color:#f92672>=</span> tracker<span style=color:#f92672>.</span>SummaryTracker()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    code_suspected_of_leak()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tr<span style=color:#f92672>.</span>print_diff()
</span></span></code></pre></td></tr></table></div></div><p>Once we run this, we get a nice table showing us a summary of objects created and destroyed:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                  types |   # objects |   total size
</span></span><span style=display:flex><span>======================= | =========== | ============
</span></span><span style=display:flex><span>                   list |        4892 |    500.59 KB
</span></span><span style=display:flex><span>                    str |        4887 |    341.45 KB
</span></span><span style=display:flex><span>                    int |        1053 |     28.79 KB
</span></span><span style=display:flex><span>                   dict |          13 |      1.90 KB
</span></span><span style=display:flex><span>         __main__.Value |          10 |    640     B
</span></span><span style=display:flex><span>  function (store_info) |           1 |    144     B
</span></span><span style=display:flex><span>                   cell |           2 |    112     B
</span></span><span style=display:flex><span>                weakref |           1 |     88     B
</span></span><span style=display:flex><span>                  tuple |          -8 |   -680     B
</span></span></code></pre></td></tr></table></div></div><p>As you can see - there are quite a few primitive objects generated, and also some <code>__main__.Value</code> objects. In my experience, primitives are harder to track, as they lack meaning in the code. Your own types, however, are usually only used in certain parts of the codebase, making them easier to make sense of.</p><p>Now that we see that we have 10 new <code>Value</code> objects, it is time to figure out who&rsquo;s holding them in memory.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>output_function</span>(o):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> str(type(o))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>all_objects <span style=color:#f92672>=</span> muppy<span style=color:#f92672>.</span>get_objects()
</span></span><span style=display:flex><span>root <span style=color:#f92672>=</span> muppy<span style=color:#f92672>.</span>filter(all_objects, Value)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>cb <span style=color:#f92672>=</span> refbrowser<span style=color:#f92672>.</span>ConsoleBrowser(root, maxdepth<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, str_func<span style=color:#f92672>=</span>output_function)
</span></span><span style=display:flex><span>cb<span style=color:#f92672>.</span>print_tree()
</span></span></code></pre></td></tr></table></div></div><p>This&rsquo;ll print the following:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;class &#39;__main__.Value&#39;&gt;-+-&lt;class &#39;list&#39;&gt;
</span></span><span style=display:flex><span>                         +-&lt;class &#39;functools._lru_cache_wrapper&#39;&gt;-+-&lt;class &#39;list&#39;&gt;
</span></span><span style=display:flex><span>                                                                  +-&lt;class &#39;dict&#39;&gt;
</span></span></code></pre></td></tr></table></div></div><p>Giving away the issue - the <code>lru_cache</code> is keeping our <code>Value</code> objects. Just as designed&mldr;</p><p>I know this looks like a bit of a contrived example, but the <code>lru_cache</code> keeping objects in memory was exactly the issue I had. It was just buried under far more code.</p><h2 id=step-3---solution><a href=#step-3---solution>Step 3 - Solution<span hidden class=anchor aria-hidden=true href=#step-3---solution>#</span></a></h2><p>Currently, I use the ugliest solution I can imagine - functions decorated with <code>lru_cache</code> have a <code>cache_clear()</code> method, and I&rsquo;m calling that at specific places in my code. It&rsquo;s ugly, but it works.</p><p>A cleaner solution would require dedicated caches & better cleanup mechanisms. You can read a relevant discussion <a href=https://bugs.python.org/issue19859>here</a>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tamir.dev/>Tamir Bahar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>