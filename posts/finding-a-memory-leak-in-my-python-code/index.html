<!doctype html><html lang=en>
<head>
<title>Finding a memory-leak in my Python code - tamir.dev</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="The HTML5 Herald">
<meta name=author content="Tamir Bahar"><meta property="og:title" content="Finding a memory-leak in my Python code">
<meta property="og:description" content="Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.tamir.dev/posts/finding-a-memory-leak-in-my-python-code/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-01-30T00:00:00+00:00">
<meta property="article:modified_time" content="2021-01-30T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Finding a memory-leak in my Python code">
<meta name=twitter:description content="Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this.">
<meta name=generator content="Hugo 0.89.0">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://www.tamir.dev/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://www.tamir.dev/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://www.tamir.dev/>tamir.dev</a>
</h1>
<ul id=social-media>
<li>
<a href=https://github.com/tmr232 title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/tmr232 title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://stackoverflow.com/users/3337893/tmr232 title=StackOverflow>
<i class="fab fa-stack-overflow fa-lg"></i>
</a>
</li>
<li>
<a href=https://dev.to/tmr232 title=devto>
<i class="fab fa-dev fa-lg"></i>
</a>
</li>
</ul>
</header>
<nav>
<ul>
</ul>
</nav>
<main>
<article>
<h1>Finding a memory-leak in my Python code</h1>
<aside>
<ul>
<li>
<time class=post-date datetime=2021-01-30T00:00:00Z>Jan 30, 2021</time>
</li>
<li>4 minute read</li>
</ul>
</aside>
<p>Last week I had to fix a memory leak in a Python program for the first time. A long running process started eating too much RAM (only ~20GB to much) and the friendly OOM Killer had to step in and terminate this. Since this kept happening, I had to go ahead and fix the issue.</p>
<h2 id=step-1---reproduction>Step 1 - Reproduction</h2>
<p>As with every bug, before you can reliably fix it, you must reproduce it.</p>
<p>Now, while I had a reliable reproduction (after all, the process had regular dates with the OOM Killer), 3 days isn&rsquo;t the best cycle time when you wanna solve a bug. So into the code we go.</p>
<p>The main idea is to start with the main loop, and try to narrow down the code that is must run for the leak to manifest. The process involves some educated guesses (where are the likely memory and allocation hogs in your process? What parts are likely to leak? Do you have any code that requires cleanup?), waiting, frustration, and tools.</p>
<h3 id=tracemalloc>tracemalloc</h3>
<p>While each developer and codebase have their own unique guesses and frustrations, good tooling applies more widely. For this part, I used Python&rsquo;s <a href=https://docs.python.org/3/library/tracemalloc.html>tracemalloc module</a>.</p>
<p>Among other things, <code>tracemalloc</code> allows tracking memory usage between 2 points in your code in a very low-overhead manner.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>tracemalloc<span style=color:#f92672>.</span>start() <span style=color:#75715e># Start the memory trace</span>

code_suspected_of_leak()

current, peak <span style=color:#f92672>=</span> tracemalloc<span style=color:#f92672>.</span>get_traced_memory() <span style=color:#75715e># Get memory stats</span>
</code></pre></div><p>After running this code, <code>peak</code> will hold the peak-memory-usage during the trace period, and <code>current</code> will hold the difference from the start of the trace to the current state. You should expect <code>current</code> to be non-zero. But if it goes too high - your code is probably leaking.</p>
<p>By placing such traces around suspect pieces of our code, we can find which parts are leaking. Just remember - only do this with functions that are expected to retain no state. If a function mutates an external object, or is a member function, it is very to exhibit changes in memory usage.</p>
<h2 id=step-2---triage>Step 2 - Triage</h2>
<p>Once we have a reproduction (that hopefully takes a relatively short amount of time), we want to find the leaking code. We can try and keep narrowing our measured code down until we find the relevant line, but the deeper we go, the harder it is to separate the leak from normal execution.</p>
<p>So at this point, we&rsquo;d like to look into the allocated memory, and see which objects are there when they shouldn&rsquo;t be.</p>
<h3 id=pympler>pympler</h3>
<p>For inspecting the objects in a Python process, I recommend using <a href=https://pympler.readthedocs.io/en/latest/><code>pympler</code></a>.</p>
<blockquote>
<p>Pympler is a development tool to measure, monitor and analyze the memory behavior of Python objects in a running Python application.</p>
</blockquote>
<p>We&rsquo;re going to use it to do 2 things.</p>
<h4 id=inspecting-allocated-objects>Inspecting Allocated Objects</h4>
<p>First, we&rsquo;re going to use <code>pympler</code> to show us which objects were allocated during our repro & are still allocated.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> pympler <span style=color:#f92672>import</span> tracker, muppy, refbrowser
<span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> lru_cache

<span style=color:#75715e># Naive code to trigger a leak</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Value</span>:
    <span style=color:#66d9ef>def</span> __init__(self, value):
        self<span style=color:#f92672>.</span>_value <span style=color:#f92672>=</span> value

    <span style=color:#66d9ef>def</span> __repr__(self):
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Value(</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>_value<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>


<span style=color:#a6e22e>@lru_cache</span>(maxsize<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_value</span>(value):
    <span style=color:#66d9ef>return</span> Value(value)


<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>code_suspected_of_leak</span>():
    <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
        print(get_value(x))

<span style=color:#75715e># Measuring code</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
    tr <span style=color:#f92672>=</span> tracker<span style=color:#f92672>.</span>SummaryTracker()

    code_suspected_of_leak()

    tr<span style=color:#f92672>.</span>print_diff()
</code></pre></div><p>Once we run this, we get a nice table showing us a summary of objects created and destroyed:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                  types |   # objects |   total size
======================= | =========== | ============
                   list |        4892 |    500.59 KB
                    str |        4887 |    341.45 KB
                    int |        1053 |     28.79 KB
                   dict |          13 |      1.90 KB
         __main__.Value |          10 |    640     B
  function (store_info) |           1 |    144     B
                   cell |           2 |    112     B
                weakref |           1 |     88     B
                  tuple |          -8 |   -680     B
</code></pre></div><p>As you can see - there are quite a few primitive objects generated, and also some <code>__main__.Value</code> objects. In my experience, primitives are harder to track, as they lack meaning in the code. Your own types, however, are usually only used in certain parts of the codebase, making them easier to make sense of.</p>
<p>Now that we see that we have 10 new <code>Value</code> objects, it is time to figure out who&rsquo;s holding them in memory.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>output_function</span>(o):
    <span style=color:#66d9ef>return</span> str(type(o))

all_objects <span style=color:#f92672>=</span> muppy<span style=color:#f92672>.</span>get_objects()
root <span style=color:#f92672>=</span> muppy<span style=color:#f92672>.</span>filter(all_objects, Value)[<span style=color:#ae81ff>0</span>]
cb <span style=color:#f92672>=</span> refbrowser<span style=color:#f92672>.</span>ConsoleBrowser(root, maxdepth<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, str_func<span style=color:#f92672>=</span>output_function)
cb<span style=color:#f92672>.</span>print_tree()
</code></pre></div><p>This&rsquo;ll print the following:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>&lt;class &#39;__main__.Value&#39;&gt;-+-&lt;class &#39;list&#39;&gt;
                         +-&lt;class &#39;functools._lru_cache_wrapper&#39;&gt;-+-&lt;class &#39;list&#39;&gt;
                                                                  +-&lt;class &#39;dict&#39;&gt;
</code></pre></div><p>Giving away the issue - the <code>lru_cache</code> is keeping our <code>Value</code> objects. Just as designed&mldr;</p>
<p>I know this looks like a bit of a contrived example, but the <code>lru_cache</code> keeping objects in memory was exactly the issue I had. It was just buried under far more code.</p>
<h2 id=step-3---solution>Step 3 - Solution</h2>
<p>Currently, I use the ugliest solution I can imagine - functions decorated with <code>lru_cache</code> have a <code>cache_clear()</code> method, and I&rsquo;m calling that at specific places in my code. It&rsquo;s ugly, but it works.</p>
<p>A cleaner solution would require dedicated caches & better cleanup mechanisms. You can read a relevant discussion <a href=https://bugs.python.org/issue19859>here</a>.</p>
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://www.tamir.dev/posts/til-python-attribute-lookup-order-is-tricky/><i class="fa fa-chevron-circle-left"></i> TIL Python attribute lookup order is tricky</a>
</li>
<li>
<a href=https://www.tamir.dev/posts/gitlab-ci-tricks/>GitLab CI Tricks <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>Copyright © 2021 - Tamir Bahar |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://www.tamir.dev/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://www.tamir.dev/js/scripts.js></script>
</body>
</html>