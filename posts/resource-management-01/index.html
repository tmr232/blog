<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Resource Management Models | Tamir Bahar</title><meta name=keywords content><meta name=description content="An overview of different resource management models"><meta name=author content="Tamir Bahar"><link rel=canonical href=https://tamir.dev/posts/resource-management-01/><link crossorigin=anonymous href=/assets/css/stylesheet.0b7a6a59f13c612205962144f1a8f43a859c4d814d43709a9e3e2b0e9353224b.css integrity="sha256-C3pqWfE8YSIFliFE8aj0OoWcTYFNQ3Canj4rDpNTIks=" rel="preload stylesheet" as=style><link rel=icon href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=16x16 href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=32x32 href=https://tamir.dev/images/profilepic.jpg><link rel=apple-touch-icon href=https://tamir.dev/images/profilepic.jpg><link rel=mask-icon href=https://tamir.dev/images/profilepic.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=webmention href=https://webmention.io/tamir.dev/webmention><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Resource Management Models"><meta property="og:description" content="An overview of different resource management models"><meta property="og:type" content="article"><meta property="og:url" content="https://tamir.dev/posts/resource-management-01/"><meta property="og:image" content="https://tamir.dev/images/profilepic.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-05T00:00:00+00:00"><meta property="og:site_name" content="Tamir Bahar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tamir.dev/images/profilepic.jpg"><meta name=twitter:title content="Resource Management Models"><meta name=twitter:description content="An overview of different resource management models"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamir.dev/posts/"},{"@type":"ListItem","position":2,"name":"Resource Management Models","item":"https://tamir.dev/posts/resource-management-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Resource Management Models","name":"Resource Management Models","description":"An overview of different resource management models","keywords":[],"articleBody":"In the last couple of years, I’ve been thinking a lot about resource management in different programming languages. The parts I’m happy with, the parts I wanna rant about, and the tradeoffs at play. I have some topics in that space that I want to talk about, but it constantly feels like I need to give way too much context to even get started. So today, I want to share some of my mental model for resource management. Both to enable me to draw on it later; and to let others discuss it in similar terms.\nAs we’re going to be talking about resources, the first thing to do is clarify what I mean when I write “resource”, and a few other useful definitions.\nDefinitions A resource is anything that has a acquire-use-release cycle. It can be memory, allocated, used, then released; it can be a lock, acquired to access a shared state; it can be a file, opened for a read operation, then closed. If it fits the pattern, it’s a resource.\nResources can generally be split into two categories: counted resources and unique resources. Counted resources are resources with a finite supply, but where the identity of the resource itself is immaterial. Memory is a counted resource - it’s a problem if it runs out, but I don’t generally care about the specific memory addresses. Another example, specifically on Windows, is handles1. We only care about them when they run out. With unique resources, however, we care deeply about the identity of the resource. Think about locks, or files, or database transactions. No two are the same. This leads to a bit of a difference in handling them. While counted resources can be released at any time before we run out without negative effects; unique resources need to be released as soon as we’re done using them, or problems are likely to occur.\nResources are, from acquisition to release, owned. Ownership of a resource is the unique responsibility to release it.\nResource management is the art of wrangling resources and their ownership. There are many approaches to resource management, and we’ll review some of them. Our motivation, as we do so, is to reach an ideal of resource management. Our goal is to have clear and transferrable ownership of resources. Clear ownership means that the question “do I own this resource?” can be answered locally, and without ambiguity. This is critical for the proper operation of a program, as ambiguity leads to confusion and bugs. Transferrable ownership is the ability to move the ownership from one owner to another. This is a key component in being able to return resources from functions. As we move forward, we’ll see that there’s often a tradeoff between clarity and transferability.\nDifferent Models Now, with our definitions and goals in mind, we can start looking into different techniques for managing resources. Specifically, we’ll focus on the solutions provided by programming languages, rather than coding techniques to work with them.\nManual Manual management of resources is the simplest model. As such, it is available in most any programming language. It gives the programmer two primitives - acquire and release - and leaves them to manage everything on their own.\nOn the positive side - we have full control. We can easily transfer ownership of a resource as a function argument, or a return value.\n1 2 3 4 5 6 7 8 9 10 def open_config(): config_file = open(\"config path\") return config_file # Here we transfer ownership to the caller. def close_config(config_file): config_file.close() def main(): config_file = open_config() # Transfer ownership from callee close_config(config_file) # Transfer ownership to callee On the other hand - we can’t do local reasoning to deduce the owner. We have to read documentation, or other code, and do complicated bookkeeping, just to know if we need to release a resource.\nUsually, when we think of the downsides of manual management, we think of C’s manual memory management, and the issues that arise there. Considering the following examples, can you easily tell which memory needs to be freed?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void example(char* ptr) { // ptr is a function argument. We must document whether we take // ownership when called, as there's no way to deduce it. // p is the sole pointer to the memory, so we must call `free(p)` // before leaving the scope. void* p = malloc(10); // Define a static string. const char* greeting = \"Hello, Bugs!\"; // strdup allocates internally, so we need to `free()` the memory. char* greeting2 = strdup(greeting); // strstr returns a pointer to our static string, // so we don't `free()` it. char* bugs = strstr(greeting, \"Bugs\"); // inet_ntoa returns a pointer to a _shared_ buffer. // Not only we can't free it, but the next call to the function // will change the value we're already holding. char* text_address = inet_ntoa(ip_address); } Scoped With scoped ownership, a resource is owned by a lexical scope. This is usually a block or a function, depending on the language. It is expressed differently in different languages, but the idea is the same. The resource is:\nis acquired before or on entering the scope; can be used inside the scope; automatically released on leaving the scope. In Python2, this is expressed as:\n1 2 3 4 5 6 # The call to `open` acquires the file, # then the `with` statement binds it to the scope. with open(\"my file\") as f: # The file is used inside the scope. f.read() # Upon leaving the scope, the file is closed. This makes ownership very clear. Look at the code - if you see an owning scope, it owns the resource. We never have to go beyond the current function to infer ownership.\nOn the other hand, this makes transferring resources impossible. Once a scope owns a resource, it will be sure to release it. If we return to our previous Python example, we’ll see that we can no longer return our resource from our function:\n1 2 3 4 5 6 def open_config(): with open(\"config path\") as config_file: return config_file # We return a file, but it'll be closed. def main(): config_file = open_config() # Here the file is already closed! We can easily pass resources to our callees, without transferring ownership:\n1 2 with open(\"my file\") as file: print_file(file) # No transfer of ownership. But the other direction is now impossible.\nWe traded transferability for clarity. As a result, we have fewer bugs, but also reduced control. So while this is a good approach, it cannot fully replace manual management.\nGarbage Collection With garbage collection we take an entirely different approach, circumventing the issue. Instead of transferring ownership from one place to the other, we have a single owner for everything. The language runtime owns the memory.\nScoped management kept you from returning resources from functions? That’s no longer an issue - the runtime will hold them for you!\nManual management had you confused about ownership? Not an issue - the runtime owns your memory!\n1 2 3 4 5 6 7 def f(): # Return a value, not an issue! return \"This is a string, backed by runtime-owned memory!\" def g(x): # The runtime owns `x`, so don't worry about it! pass But you’ve probably noticed me cheating here. Before, we talked about resources. Now, we’re only talking about memory.\nThis is because memory, being a counted resource, is inherently different from the unique resources that make up what we usually think of when we say “resource”. Since we only care about having enough memory, it’s ok if the GC take a moment, or even a long moment, before it releases it. There are even situations where it’s ok if it never releases that memory.\nWith unique resources, this doesn’t work. If you hold a lock, you need it to be released now. If you’re managing a database transaction, you want to finalize it before the next one. You need control, and a GC (Garbage Collector) doesn’t give you that.\nIn this case, the tradeoff between clarity \u0026 transferability, between simplicity and power, is entirely untenable for some use-cases. Unlike the manual-or-scoped tradeoff, this one cannot be circumvented by clever design. That’s why we only have it for memory management.\nMove Semantics (or “whatever Rust does”) Instead of going into the weeds of C++’s move semantics or Rust’s ownership model, I’ll lay out the basic principles, as a combination of concepts discussed before.\nAll resources are scope-managed and scope-owned. Always and by default. Ownership can be transferred clearly to a different scope. This means that we get our goal - clear and transferrable ownership. We can easily deduce the owner when looking at a piece of code, and we can transfer the ownership to a different scope if needed. Unfortunately, this doesn’t come free. We have to explicitly reason about, and decide, on things that were implicit before.\nConsider a linked list for example. With a singly-linked list, we can say that the head owns the first node, which owns the next node, and so on. But with a doubly-linked list, there is no “obvious” solution. Is a node owned by the next node, or the previous one? Being owned by both would be an issue, as we already said there can be only one owner. Such issues make this model considerably harder to learn and adapt to.\nConclusion Now that we’ve seen all four models, we can put them in a nice table to compare them:\nModel Clear Transferrable Simple Complete Manual Yes Yes Scoped Yes Yes Maybe? GC Yes Yes Move Yes Yes Maybe? I added two columns that we did not discuss explicitly. “Simple” is for simplicity, which we mentioned throughout. “Complete” is whether we can do with that model alone, and not require the others. Scoped get’s a “maybe” here because if you use enough Dependency Injection you might just be able to get it working. That said, I don’t recommend it.\nWith no single model getting a “yes” on all columns, we’ve yet to find the “best solution”. Until then, we’ll have to keep mixing and matching to solve the problems we’re facing to the best of our ability.\nSee Why is the limit of window handles per process 10,000? and Pushing the Limits of Windows: Handles ↩︎\nSee Python with statement ↩︎\n","wordCount":"1745","inLanguage":"en","datePublished":"2023-08-05T00:00:00Z","dateModified":"2023-08-05T00:00:00Z","author":{"@type":"Person","name":"Tamir Bahar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamir.dev/posts/resource-management-01/"},"publisher":{"@type":"Organization","name":"Tamir Bahar","logo":{"@type":"ImageObject","url":"https://tamir.dev/images/profilepic.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamir.dev/ accesskey=h title="Tamir Bahar (Alt + H)">Tamir Bahar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamir.dev/blogvent/ title=blogvent🎄><span>blogvent🎄</span></a></li><li><a href=https://tamir.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://tamir.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://tamir.dev/index.xml title=rss><span>rss</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="13"><g transform="scale(1)"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></g></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamir.dev/>Home</a>&nbsp;»&nbsp;<a href=https://tamir.dev/posts/>Posts</a></div><h1 class=post-title>Resource Management Models</h1><div class=post-description>An overview of different resource management models</div><div class=post-meta><span title='2023-08-05 00:00:00 +0000 UTC'>Aug 5, 2023</span>&nbsp;·&nbsp;Tamir Bahar</div></header><div class=post-content><p>In the last couple of years, I&rsquo;ve been thinking a lot about resource management in different programming languages.
The parts I&rsquo;m happy with, the parts I wanna rant about, and the tradeoffs at play.
I have some topics in that space that I want to talk about, but it constantly feels like I need to give <em>way</em> too much context to even get started.
So today, I want to share <em>some</em> of my mental model for resource management.
Both to enable me to draw on it later; and to let others discuss it in similar terms.</p><p>As we&rsquo;re going to be talking about resources, the first thing to do is clarify what I mean when I write &ldquo;resource&rdquo;, and a few other useful definitions.</p><h3 id=definitions><a href=#definitions>Definitions<span hidden class=anchor aria-hidden=true href=#definitions>#</span></a></h3><p>A <strong>resource</strong> is anything that has a <strong>acquire-use-release</strong> cycle.
It can be memory, allocated, used, then released;
it can be a lock, acquired to access a shared state;
it can be a file, opened for a read operation, then closed.
If it fits the pattern, it&rsquo;s a resource.</p><p>Resources can generally be split into two categories: <strong>counted</strong> resources and <strong>unique</strong> resources.
<strong>Counted resources</strong> are resources with a finite supply, but where the identity of the resource itself is immaterial.
Memory is a counted resource - it&rsquo;s a problem if it runs out, but I don&rsquo;t generally care about the specific memory addresses.
Another example, specifically on Windows, is handles<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.
We only care about them when they run out.
With <strong>unique resources</strong>, however, we care deeply about the identity of the resource.
Think about locks, or files, or database transactions.
No two are the same.
This leads to a bit of a difference in handling them.
While <strong>counted resources</strong> can be released at any time before we run out without negative effects; <strong>unique resources</strong> need to be released as soon as we&rsquo;re done using them, or problems are likely to occur.</p><p>Resources are, from acquisition to release, owned.
<strong>Ownership</strong> of a resource is the <em>unique responsibility to release it</em>.</p><p>Resource management is the art of wrangling <strong>resources</strong> and their <strong>ownership</strong>.
There are many approaches to resource management, and we&rsquo;ll review some of them.
Our motivation, as we do so, is to reach an ideal of resource management.
Our goal is to have <em>clear and transferrable ownership of resources</em>.
<strong>Clear</strong> ownership means that the question &ldquo;do I own this resource?&rdquo; can be answered locally, and without ambiguity.
This is critical for the proper operation of a program, as ambiguity leads to confusion and bugs.
<strong>Transferrable</strong> ownership is the ability to move the ownership from one owner to another.
This is a key component in being able to return resources from functions.
As we move forward, we&rsquo;ll see that there&rsquo;s often a tradeoff between clarity and transferability.</p><h2 id=different-models><a href=#different-models>Different Models<span hidden class=anchor aria-hidden=true href=#different-models>#</span></a></h2><p>Now, with our definitions and goals in mind, we can start looking into different techniques for managing resources.
Specifically, we&rsquo;ll focus on the solutions provided by programming languages, rather than coding techniques to work with them.</p><h3 id=manual><a href=#manual>Manual<span hidden class=anchor aria-hidden=true href=#manual>#</span></a></h3><p>Manual management of resources is the simplest model.
As such, it is available in most any programming language.
It gives the programmer two primitives - acquire and release - and leaves them to manage everything on their own.</p><p>On the positive side - we have full control.
We can easily transfer ownership of a resource as a function argument, or a return value.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>open_config</span>():
</span></span><span style=display:flex><span>	config_file <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;config path&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> config_file  <span style=color:#75715e># Here we transfer ownership to the caller.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>close_config</span>(config_file):
</span></span><span style=display:flex><span>	config_file<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>	config_file <span style=color:#f92672>=</span> open_config() <span style=color:#75715e># Transfer ownership from callee</span>
</span></span><span style=display:flex><span>	close_config(config_file)   <span style=color:#75715e># Transfer ownership to callee</span>
</span></span></code></pre></td></tr></table></div></div><p>On the other hand - we can&rsquo;t do local reasoning to deduce the owner.
We have to read documentation, or other code, and do complicated bookkeeping, just to know if we need to release a resource.</p><p>Usually, when we think of the downsides of manual management, we think of C&rsquo;s manual memory management, and the issues that arise there.
Considering the following examples, can you easily tell which memory needs to be freed?</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>example</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> ptr) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ptr is a function argument. We must document whether we take
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ownership when called, as there&#39;s no way to deduce it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// p is the sole pointer to the memory, so we must call `free(p)`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// before leaving the scope.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Define a static string.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> greeting <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, Bugs!&#34;</span>;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// strdup allocates internally, so we need to `free()` the memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> greeting2 <span style=color:#f92672>=</span> strdup(greeting);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// strstr returns a pointer to our static string,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// so we don&#39;t `free()` it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bugs <span style=color:#f92672>=</span> strstr(greeting, <span style=color:#e6db74>&#34;Bugs&#34;</span>);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// inet_ntoa returns a pointer to a _shared_ buffer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Not only we can&#39;t free it, but the next call to the function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will change the value we&#39;re already holding.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> text_address <span style=color:#f92672>=</span> inet_ntoa(ip_address);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=scoped><a href=#scoped>Scoped<span hidden class=anchor aria-hidden=true href=#scoped>#</span></a></h3><p>With scoped ownership, a resource is owned by a lexical scope.
This is usually a block or a function, depending on the language.
It is expressed differently in different languages, but the idea is the same.
The resource is:</p><ul><li>is acquired before or on entering the scope;</li><li>can be used inside the scope;</li><li>automatically released on leaving the scope.</li></ul><p>In Python<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, this is expressed as:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># The call to `open` acquires the file,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># then the `with` statement binds it to the scope.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;my file&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>	<span style=color:#75715e># The file is used inside the scope.</span>
</span></span><span style=display:flex><span>	f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span><span style=color:#75715e># Upon leaving the scope, the file is closed.</span>
</span></span></code></pre></td></tr></table></div></div><p>This makes ownership very clear.
Look at the code - if you see an owning scope, it owns the resource.
We never have to go beyond the current function to infer ownership.</p><p>On the other hand, this makes transferring resources impossible.
Once a scope owns a resource, it will be sure to release it.
If we return to our previous Python example, we&rsquo;ll see that we can no longer return our resource from our function:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>open_config</span>():
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;config path&#34;</span>) <span style=color:#66d9ef>as</span> config_file:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> config_file  <span style=color:#75715e># We return a file, but it&#39;ll be closed.</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>	config_file <span style=color:#f92672>=</span> open_config() <span style=color:#75715e># Here the file is already closed!</span>
</span></span></code></pre></td></tr></table></div></div><p>We can easily pass resources <em>to</em> our callees, without transferring ownership:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;my file&#34;</span>) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>	print_file(file)  <span style=color:#75715e># No transfer of ownership.</span>
</span></span></code></pre></td></tr></table></div></div><p>But the other direction is now impossible.</p><p>We traded transferability for clarity.
As a result, we have fewer bugs, but also reduced control.
So while this is a good approach, it cannot fully replace manual management.</p><h3 id=garbage-collection><a href=#garbage-collection>Garbage Collection<span hidden class=anchor aria-hidden=true href=#garbage-collection>#</span></a></h3><p>With garbage collection we take an entirely different approach, circumventing the issue.
Instead of transferring ownership from one place to the other, we have a single owner for everything.
The <strong>language runtime</strong> owns the memory.</p><p>Scoped management kept you from returning resources from functions?
That&rsquo;s no longer an issue - the runtime will hold them for you!</p><p>Manual management had you confused about ownership?
Not an issue - the runtime owns your memory!</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>():
</span></span><span style=display:flex><span>	<span style=color:#75715e># Return a value, not an issue!</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;This is a string, backed by runtime-owned memory!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>g</span>(x):
</span></span><span style=display:flex><span>	<span style=color:#75715e># The runtime owns `x`, so don&#39;t worry about it!</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pass</span>
</span></span></code></pre></td></tr></table></div></div><p>But you&rsquo;ve probably noticed me cheating here.
Before, we talked about resources.
Now, we&rsquo;re only talking about memory.</p><p>This is because memory, being a <strong>counted resource</strong>, is inherently different from the <strong>unique resources</strong> that make up what we usually think of when we say &ldquo;resource&rdquo;.
Since we only care about having <em>enough</em> memory, it&rsquo;s ok if the GC take a moment, or even a long moment, before it releases it.
There are even situations where it&rsquo;s ok if it <em>never</em> releases that memory.</p><p>With unique resources, this doesn&rsquo;t work.
If you hold a lock, you need it to be released <em>now</em>.
If you&rsquo;re managing a database transaction, you want to finalize it <em>before</em> the next one.
You need control, and a GC (Garbage Collector) doesn&rsquo;t give you that.</p><p>In this case, the tradeoff between clarity & transferability, between simplicity and power, is entirely untenable for some use-cases.
Unlike the manual-or-scoped tradeoff, this one cannot be circumvented by clever design.
That&rsquo;s why we only have it for memory management.</p><h3 id=move-semantics-or-whatever-rust-does><a href=#move-semantics-or-whatever-rust-does>Move Semantics (or &ldquo;whatever Rust does&rdquo;)<span hidden class=anchor aria-hidden=true href=#move-semantics-or-whatever-rust-does>#</span></a></h3><p>Instead of going into the weeds of <a href=https://stackoverflow.com/questions/3106110/what-is-move-semantics>C++&rsquo;s move semantics</a> or <a href=https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#ownership-rules>Rust&rsquo;s ownership model</a>, I&rsquo;ll lay out the basic principles, as a combination of concepts discussed before.</p><ul><li>All resources are scope-managed and scope-owned. Always and by default.</li><li>Ownership can be transferred clearly to a different scope.</li></ul><p>This means that we get our goal - clear and transferrable ownership.
We can easily deduce the owner when looking at a piece of code, and we can transfer the ownership to a different scope if needed.
Unfortunately, this doesn&rsquo;t come free.
We have to explicitly reason about, and decide, on things that were implicit before.</p><p>Consider a linked list for example.
With a singly-linked list, we can say that the head owns the first node, which owns the next node, and so on.
But with a doubly-linked list, there is no &ldquo;obvious&rdquo; solution.
Is a node owned by the next node, or the previous one?
Being owned by both would be an issue, as we already said there can be only one owner.
Such issues make this model considerably harder to learn and adapt to.</p><h2 id=conclusion><a href=#conclusion>Conclusion<span hidden class=anchor aria-hidden=true href=#conclusion>#</span></a></h2><p>Now that we&rsquo;ve seen all four models, we can put them in a nice table to compare them:</p><table><thead><tr><th>Model</th><th>Clear</th><th>Transferrable</th><th>Simple</th><th>Complete</th></tr></thead><tbody><tr><td>Manual</td><td></td><td>Yes</td><td></td><td>Yes</td></tr><tr><td>Scoped</td><td>Yes</td><td></td><td>Yes</td><td>Maybe?</td></tr><tr><td>GC</td><td>Yes</td><td></td><td>Yes</td><td></td></tr><tr><td>Move</td><td>Yes</td><td>Yes</td><td></td><td>Maybe?</td></tr></tbody></table><p>I added two columns that we did not discuss explicitly.
&ldquo;Simple&rdquo; is for simplicity, which we mentioned throughout.
&ldquo;Complete&rdquo; is whether we can do with that model alone, and not require the others.
Scoped get&rsquo;s a &ldquo;maybe&rdquo; here because if you use enough <a href=https://en.wikipedia.org/wiki/Dependency_injection>Dependency Injection</a> you might just be able to get it working.
That said, I don&rsquo;t recommend it.</p><p>With no single model getting a &ldquo;yes&rdquo; on all columns, we&rsquo;ve yet to find the &ldquo;best solution&rdquo;.
Until then, we&rsquo;ll have to keep mixing and matching to solve the problems we&rsquo;re facing to the best of our ability.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>See <a href="https://devblogs.microsoft.com/oldnewthing/20070718-00/?p=25963">Why is the limit of window handles per process 10,000?</a> and <a href=https://techcommunity.microsoft.com/t5/windows-blog-archive/pushing-the-limits-of-windows-handles/ba-p/723848>Pushing the Limits of Windows: Handles</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>See <a href=https://docs.python.org/3/reference/compound_stmts.html#with>Python <code>with</code> statement</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul><div style=display:flex;justify-content:center class=discuss><a href=https://github.com/tmr232/tamir.dev/discussions/7 target=_blank rel="noopener noreferrer me" title="Discuss this post">Discuss this post<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="1em" style="margin-bottom:-.2em;margin-left:.2em"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tamir.dev/>Tamir Bahar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>