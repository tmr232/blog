<!doctype html><html lang=en>
<head>
<title>That `overloaded` Trick: Overloading Lambdas in C++17 - tamir.dev</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Kiera: A Hugo theme for creative and technical writing.">
<meta name=author content="Tamir Bahar"><meta property="og:title" content="That `overloaded` Trick: Overloading Lambdas in C++17">
<meta property="og:description" content="C++17 has granted us with std::variant. Simply put, it is a type-safe union. To access the value it stores, you can either request a specific type (using std::get or something similar) or &ldquo;visit&rdquo; the variant, automatically handling only the data-type that is actually there.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.example.org/posts/that-overloaded-trick-overloading-lambdas-in-cpp17/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-08-15T00:00:00+00:00">
<meta property="article:modified_time" content="2017-08-15T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="That `overloaded` Trick: Overloading Lambdas in C++17">
<meta name=twitter:description content="C++17 has granted us with std::variant. Simply put, it is a type-safe union. To access the value it stores, you can either request a specific type (using std::get or something similar) or &ldquo;visit&rdquo; the variant, automatically handling only the data-type that is actually there.">
<meta name=generator content="Hugo 0.89.0">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous>
<link rel=stylesheet href=https://www.example.org/fontawesome/css/all.min.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda">
<link rel=stylesheet type=text/css href=https://www.example.org/css/styles.css></head>
<body>
<div id=container>
<header>
<h1>
<a href=https://www.example.org/>tamir.dev</a>
</h1>
<ul id=social-media>
<li>
<a href=https://github.com/tmr232 title=GitHub>
<i class="fab fa-github fa-lg"></i>
</a>
</li>
<li>
<a href=https://twitter.com/tmr232 title=Twitter>
<i class="fab fa-twitter fa-lg"></i>
</a>
</li>
<li>
<a href=https://stackoverflow.com/tmr232 title=StackOverflow>
<i class="fab fa-stack-overflow fa-lg"></i>
</a>
</li>
<li>
<a href=https://dev.to/tmr232 title=devto>
<i class="fab fa-dev fa-lg"></i>
</a>
</li>
</ul>
<p><em>A Hugo theme for creative and technical writing</em></p>
</header>
<nav>
<ul>
</ul>
</nav>
<main>
<article>
<h1>That `overloaded` Trick: Overloading Lambdas in C++17</h1>
<aside>
<ul>
<li>
<time class=post-date datetime=2017-08-15T00:00:00Z>Aug 15, 2017</time>
</li>
<li>5 minute read</li>
</ul>
</aside>
<p>C++17 has granted us with <a href=http://en.cppreference.com/w/cpp/utility/variant><code>std::variant</code></a>. Simply put, it is a type-safe <code>union</code>. To access the value it stores, you can either request a specific type (using <a href=http://en.cppreference.com/w/cpp/utility/variant/get><code>std::get</code></a> or something similar) or &ldquo;visit&rdquo; the variant, automatically handling only the data-type that is actually there.
Visiting is done using <a href=http://en.cppreference.com/w/cpp/utility/variant/visit><code>std::visit</code></a>, and is fairly straight forward.</p>
<p><a href=https://godbolt.org/g/UhTBtD>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/ce02024f6539db91>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> var_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Print</span> { <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>() (<span style=color:#66d9ef>int</span> i) {
        printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i);
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span> () (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) {
        puts(str);
    }
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>}; <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(Print{}, v); <span style=color:#75715e>// (4)
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define our variant type. In (2) we define a class with an overloaded <code>operator()</code>. This is needed for the call to <code>std::visit</code>. In (3) we define a vector of variants. In (4) we visit each variant. We pass in an instance of <code>Print</code>, and overload resolution ensures that the correct overload will be called for every type.
But this example forces us to write and name an object for the overloaded <code>operator()</code>. We can do better. In fact, the example for <code>std::visit</code> on <a href=http://en.cppreference.com/w/cpp/utility/variant/visit>cppreference</a> already does. Here is an example derived from it:</p>
<p><a href=https://godbolt.org/g/8gAj3y>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/2edc87064e156115>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>overloaded</span> <span style=color:#f92672>:</span> Ts... { <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...; }; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> overloaded(Ts...) <span style=color:#f92672>-&gt;</span> overloaded<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>;  <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> var_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(overloaded {  <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>            [](<span style=color:#66d9ef>int</span> i) { printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i); },
            [](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) { puts(str); }
        }, v);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>This is certainly more compact, and we removed the <code>Print</code> struct. But how does it work? You can see a class-template (1), lambdas passed in as arguments for the construction (3), and something with an arrow and some more template magic (2). Let&rsquo;s build it step by step.</p>
<p>First, we want to break the print functions out of <code>Print</code> and compose them later.</p>
<p><a href=https://godbolt.org/g/ZuyYrD>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/4e90f3c2ae1a5113>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PrintInt</span> { <span style=color:#75715e>//(1)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>() (<span style=color:#66d9ef>int</span> i) {
        printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i);
    }
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PrintCString</span> { <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span> () (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) {
        puts(str);
    }
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Print</span> <span style=color:#f92672>:</span> PrintInt, PrintCString { <span style=color:#75715e>// (3)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>using</span> PrintInt<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>();
    <span style=color:#66d9ef>using</span> PrintCString<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>();
};
</code></pre></div><p>In (1) and (2), we define the same operators as before, but in separate structs. In (3), we are inherit from both of those structs, then explicitly use their <code>operator()</code>. This results in exactly the same results as before. Next, we convert <code>Print</code> into a class template. I&rsquo;ll jump ahead and convert it directly to a variadic template.</p>
<p><a href=https://godbolt.org/g/iXGT2p>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/3e9902784fec5791>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Print</span> <span style=color:#f92672>:</span> Ts... {
    <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...;
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(Print<span style=color:#f92672>&lt;</span>PrintCString, PrintInt<span style=color:#f92672>&gt;</span>{}, v); <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define the template. We take an arbitrary number of classes, inherit from them, and use their <code>operator()</code>. In (2) we instantiate the <code>Print</code> class-template with <code>PrintCString</code> and <code>PrintInt</code> to get their functionality.
Next, we want to use <a href=http://en.cppreference.com/w/cpp/language/lambda>lambdas</a> to do the same. This is possible because lambdas are not functions; they are objects implementing <code>operator()</code>.</p>
<p><a href=https://godbolt.org/g/bFzYUP>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/ed95f8db6c30562e>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>};
    <span style=color:#66d9ef>auto</span> PrintInt <span style=color:#f92672>=</span> [](<span style=color:#66d9ef>int</span> i) { printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i); }; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> PrintCString <span style=color:#f92672>=</span> [](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) { puts(str); };

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(
            Print<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(PrintCString), <span style=color:#66d9ef>decltype</span>(PrintInt)<span style=color:#f92672>&gt;</span>{PrintCString, PrintInt}, <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>            v);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define the lambdas we need. In (2) we instantiate the template with our lambdas. This is ugly. Since lambdas have unique types, we need to define them before using them as template parameters (deducing their types using <code>decltype</code>). Then, we need to pass the lambdas as arguments for <a href=http://en.cppreference.com/w/cpp/language/aggregate_initialization>aggregate initialization</a> as lambdas have a delete default constructor. We are close, but not quite there yet.
The <code>&lt;decltype(PrintCString), decltype(PrintInt)></code> part is really ugly, and causes repetition. But it is needed as ctors cannot do type-deduction. So in proper C++ style, we will create a function to circumvent that.</p>
<p><a href=https://godbolt.org/g/S3XGZr>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/8f373b382ed73d3b>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> MakePrint(Ts... ts) {
    <span style=color:#66d9ef>return</span> Print<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>{ts...};
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(
            MakePrint( <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>                [](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) { puts(str); },
                [](<span style=color:#66d9ef>int</span> i) { printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i); }
                ),
            v);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define our helper function, to perform type deduction and forward it to the ctor. In (2) we take advantage of our newly found type-deduction to define the lambdas inline. But this is C++17, and we can do better.</p>
<p>C++17 added <a href=http://en.cppreference.com/w/cpp/language/class_template_argument_deduction>user-defined deduction guides</a>. Those allow us to instruct the compiler to perform the same actions as our helper function, but without adding another function. Using a suitable deduction guide, the code is as follows.</p>
<p><a href=https://godbolt.org/g/ZZXM6L>Compilation</a>, <a href=http://coliru.stacked-crooked.com/a/1bbf8c7cccedd3d8>Execution</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> var_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Print</span> <span style=color:#f92672>:</span> Ts... {
    <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...;
};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>...</span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> Print(Ts...) <span style=color:#f92672>-&gt;</span> Print<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>; <span style=color:#75715e>// (1)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>var_t<span style=color:#f92672>&gt;</span> vars <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>};

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : vars) {
        std<span style=color:#f92672>::</span>visit(
            Print{ <span style=color:#75715e>// (2)
</span><span style=color:#75715e></span>                [](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) { puts(str); },
                [](<span style=color:#66d9ef>int</span> i) { printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i); }
            },
            v);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In (1) we define a deduction guide which acts as our previous helper function, and in (2) we use the constructor instead of a helper function. Done.</p>
<p>Now we have fully recreated the original example. As <code>Print</code> is no longer indicative of the template-class' behavior, <code>overloaded</code> is probably a better name.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>overloaded</span> <span style=color:#f92672>:</span> Ts... { <span style=color:#66d9ef>using</span> Ts<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span>()...; };
<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span><span style=color:#960050;background-color:#1e0010>... </span><span style=color:#a6e22e>Ts</span><span style=color:#f92672>&gt;</span> overloaded(Ts...) <span style=color:#f92672>-&gt;</span> overloaded<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;</span>;
</code></pre></div>
</article>
<section class=post-nav>
<ul>
<li>
<a href=https://www.example.org/posts/a-functional-style-state-machine-in-cpp/><i class="fa fa-chevron-circle-left"></i> A Functional-Style State Machine in C++</a>
</li>
<li>
<a href=https://www.example.org/posts/a-functional-style-state-machine-in-cpp-part-2/>A Functional-Style State Machine in C++, Part 2 <i class="fa fa-chevron-circle-right"></i> </a>
</li>
</ul>
</section>
</main>
<footer>
<ul>
<li>
<h6>Copyright © 2021 - Tamir Bahar |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://www.example.org/index.xml>Subscribe </a></h6>
</li>
</ul>
</footer>
</div>
<script src=https://www.example.org/js/scripts.js></script>
</body>
</html>