<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Tools & Libraries | Tamir Bahar</title><meta name=keywords content><meta name=description content="Python tools & libraries that I use and would recommend"><meta name=author content><link rel=canonical href=https://tamir.dev/posts/python-tools-and-libs/><link crossorigin=anonymous href=/assets/css/stylesheet.45644aa474dc79df40198665054ee839f669de372852cf1df60cb49538828f48.css integrity="sha256-RWRKpHTced9AGYZlBU7oOfZp3jcoUs8d9gy0lTiCj0g=" rel="preload stylesheet" as=style><link rel=icon href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=16x16 href=https://tamir.dev/images/profilepic.jpg><link rel=icon type=image/png sizes=32x32 href=https://tamir.dev/images/profilepic.jpg><link rel=apple-touch-icon href=https://tamir.dev/images/profilepic.jpg><link rel=mask-icon href=https://tamir.dev/images/profilepic.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python Tools & Libraries"><meta property="og:description" content="Python tools & libraries that I use and would recommend"><meta property="og:type" content="article"><meta property="og:url" content="https://tamir.dev/posts/python-tools-and-libs/"><meta property="og:image" content="https://tamir.dev/images/profilepic.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-10T00:00:00+00:00"><meta property="og:site_name" content="Tamir Bahar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tamir.dev/images/profilepic.jpg"><meta name=twitter:title content="Python Tools & Libraries"><meta name=twitter:description content="Python tools & libraries that I use and would recommend"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamir.dev/posts/"},{"@type":"ListItem","position":2,"name":"Python Tools \u0026 Libraries","item":"https://tamir.dev/posts/python-tools-and-libs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Tools \u0026 Libraries","name":"Python Tools \u0026 Libraries","description":"Python tools \u0026 libraries that I use and would recommend","keywords":[],"articleBody":"Recently I was asked about Python tools \u0026 libraries that I use. After taking the time to write a lengthy reply, I figured I might as well write a blog post, to make it more widely available.\nThis post is going to go over some Python tools \u0026 libraries that I use and that I like.\nFormatting Automatic formatting gives you the gift of not ever caring about formatting again. Not when you resolve conflicts, not when you review code, not when you write code.\nI currently use 3 different formatters to get it done. I run autoflake, then isort, then black.\nBlack The uncompromising Python code formatter\nBlack is a code-formatter for Python with minimal (line length) configurable settings. It‚Äôs a really good code formatter, and will help avoid all the ‚Äúbut I like my code this way‚Äù complaints. Additionally, it‚Äôs now more-or-less the de-facto standard for formatting Python code.\nTo paraphrase Rob Pike, ‚ÄúBlack‚Äôs style is no one‚Äôs favorite, yet Black is everyone‚Äôs favorite.‚Äù\nisort isort sorts your imports. It sorts them alphabetically, and also groups them separating standard-library, third-parties, and your own code.\nEven if you don‚Äôt care about sorting imports - it‚Äôs going to solve a ton of import-duplication \u0026 merge-conflicts for you.\nautoflake autoflake removes unused imports. That‚Äôs it. Use it.\nLinting Just like automatic formatting - you don‚Äôt need to think about anything you can lint for. This also means you never need to argue about it.\nmypy mypy is a static type-checker for Python. It uses type annotations \u0026 type inference to tell whether your types match or not. It is not perfect, but it catches often catches major issues in my code.\nI highly recommend using it in your project from the get-go. Writing types as you code is easy. Writing types for an existing project is exhausting.\nWhile the default settings are ok, there are some extras I recommend:\ncheck-untyped-defs makes sure you get warnings even if you didn‚Äôt annotate a function at all. This one, in particular, can be annoying to turn on late into a project. strict-equality warns you if you compare non-overlapping types. Those comparisons are usually bugs. warn-return-any warns if you return an unknown type from a function annotated to return a specific type warn-no-return warns if you only have return statements in some branches of your function. This is annoying sometimes, but saves you in the cases where you actually forget to return a value. warn-unreachable warns you when a piece of code is deemed unreachable. This one is super helpful in realizing that you made a typing error. Like checking a variable that‚Äôs never None against None. And the make the output friendlier, use:\npretty show-error-context pylint Pylint, with it‚Äôs catchy tag-line (‚ÄúIt‚Äôs not just a linter that annoys you!‚Äù), is for the most part just a linter that annoys you.\nIf you set it up, and disable all the errors you don‚Äôt care about (I have over 20 disabled globally), it can give some value. But it is also painfully slow.\nIt is currently here because I still use it, but I am more and more hesitant about including it in new projects. I just don‚Äôt feel like its value is worth the time and hassle. Especially with mypy catching a lot of the true errors pylint catches.\nflake8 flake8 is a style-guide-enforcer for Python. It is fast and capable, and has a large assortment of plugins that can catch actual bugs as well.\nRuff Ruff is ‚Äúan extremely fast Python linter, written in Rust.‚Äù And it lives up to that. I don‚Äôt have much experience with it in production, so I don‚Äôt know how much it actually catches compared to the previous tools.\nRuff is now in very active development, and I plan to integrate it soon. Even if it‚Äôs missing some features you currently want, I think it‚Äôs worth keeping an eye out for it.\nTesting \u0026 Automation pytest Pytest is my test-framework of choice. The fixture-based design takes a while to get used to, and there is a bit of ‚Äúmagic‚Äù going on. But once you get the hang of it, it is extremely capable and easy to use and extend.\nnox nox makes it easy to automate your tests for multiple Python environments (think multiple versions of Python, multiple OSs, etc.).\nI find it straight-forward and easy to use and extend, as the configuration is entirely in Python.\nIn addition to tests, I use it to automate code formatting \u0026 linting, code-generation, and various CI tasks. That way I know that what I run locally and in the CI uses the same code and configuration.\nYou can also read Hynek Schlawack‚Äôs post on nox.\nProfiling \u0026 Benchmarking memray Memray is a memory profiler for Python. It does what it says on the tin, and does it well. It shows you which parts of your code allocated the most memory, and allows you to easily analyze that using multiple ‚Äúreporters‚Äù. My most-used reporters are the Flame Graph Reporter and the Tree Reporter.\nThe only major downside is that it does not support Windows (unless you‚Äôre using WSL).\nAustin Austin is a sampling profiler for Python. It is fast and capable, and I use it a lot.\nBe aware that some related tools (austin-web) are not always as up-to-date and may cause issues.\nI recommend using it to profile an entire run, and then use Speedscope to analyze it. If you need to analyze a part of a run [austin-tui][] can show a live view, and then save it to a trace file.\nThe default output format for Austin is supported by Speedscope and is also easily editable using scripts (if you want to filter out specific parts of a run).\npy-spy py-spy is another sampling profiler for Python. For me, it‚Äôs main benefit is it‚Äôs top view, which gives a good overview of a process and lets you know ‚Äúwhat‚Äôs taking so long?‚Äù. Additionally, it can show you stack traces for all the currently running threads.\nI usually use it when a running process misbehaves and I want to know why.\nThe Python Profilers The Python Profilers are for when sampling profilers aren‚Äôt enough. You need to know the call-count, and not just the durations. They don‚Äôt sample, so they will severely affect your program‚Äôs runtime. But there is no real alternative.\nFor viewing and analyzing the data, I highly recommend using KCacheGrind (or possible QCacheGrind if you‚Äôre on Windows and don‚Äôt wanna bother with setting up GUI for WSL). It is extremely fast even with very large profiles, and has some very good visualizations for analyzing the data. To convert the data to a fitting format, use pyprof2calltree\nMemory Usage Over Time Sometimes the simplest solution is the best one.\nWhen I need to find the part in my code that suddenly allocates way to much - I often log my memory usage over time, graph it, then compare it with a log or a sampling-profiler run to see which part of the run correlates with the spike in memory usage.\nIt‚Äôs crude, but it works.\nI tend to use the psutil library for it.\npytest-benchmark pytest-benchmark allows you to easily run short-benchmarks in your test-suite. It takes care of all the complicated stuff - repeating the runs, and calculating statistics - and gives you easy-to-read results.\nI also wrote a small tool on top of it to perform comparative-benchmarks and compare different implementations for the same code. You can find it at tmr232/python-benchmark.\npytest-json-report pytest-json-report generates a JSON report for a pytest run. It has 2 main benefits:\nMakes it easy to parse the test results and create custom reports Makes it easy to add extra information into the test results I use it to add peak-memory-usage into the test-results, so that I can keep track of that.\nPackaging \u0026 Deps Poetry Poetry is my go-to for managing my Python dependencies.\nThe main advantage of Poetry over other tools is that it automatically maintains a lock-file for you. By committing the lock-file into your repo, you ensure that package versions will be identical across all your environments. That way you know that what you develop with locally is the same as what‚Äôs tested in the CI, same as what‚Äôs deployed to staging, and also the same as what you deploy to production.\nI think that this alone should be enough to convince you.\nLibraries rich Rich is a Python library for rich text and beautiful formatting in the terminal.\nIf you print anything to the terminal - use Rich. It‚Äôs better than any other library in the category.\ntyper Typer, from the creator of FastAPI, makes building advanced CLIs easy and painless.\nIn it‚Äôs most basic - it takes the argument names and type annotations from a function, and converts it to a fully-features CLI (flags, arguments, documentation, completions).\nattrs attrs is my preferred way to write Python classes. It uses type annotations to declaratively define your classes, and does a fantastic work of deducing extra functionality from it (comparisons, equality, hash‚Ä¶).\nTo keep things short - I don‚Äôt remember the last time I wrote an __init__ method.\nAltair If you ever need to draw a graph, use Altair.\nFor it‚Äôs philosophy and a brief intro, I recommend watching How to Think about Data Visualization by Jake VanderPlas.\nThe only downside I found so far is that exporting an image usually requires a web-browser in the process. But if your final output is HTML - you should be good.\nPandas Yes, pandas, the data-frame library.\nIf you‚Äôre ever dealing with numeric data, it‚Äôs worth spending the time (a couple of days, in my case) to develop basic competency with pandas. Once you have that, a lot of annoying tasks that you used to do in Excel become easy and straightforward.\n","wordCount":"1641","inLanguage":"en","datePublished":"2023-02-10T00:00:00Z","dateModified":"2023-02-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tamir.dev/posts/python-tools-and-libs/"},"publisher":{"@type":"Organization","name":"Tamir Bahar","logo":{"@type":"ImageObject","url":"https://tamir.dev/images/profilepic.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamir.dev/ accesskey=h title="Tamir Bahar (Alt + H)">Tamir Bahar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamir.dev/blogvent/ title=blogventüéÑ><span>blogventüéÑ</span></a></li><li><a href=https://tamir.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://tamir.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://tamir.dev/index.xml title=rss><span>rss</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="13"><g transform="scale(1)"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></g></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamir.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://tamir.dev/posts/>Posts</a></div><h1 class=post-title>Python Tools & Libraries</h1><div class=post-description>Python tools & libraries that I use and would recommend</div><div class=post-meta><span title='2023-02-10 00:00:00 +0000 UTC'>Feb 10, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#formatting>Formatting</a><ul><li><a href=#black>Black</a></li><li><a href=#isort>isort</a></li><li><a href=#autoflake>autoflake</a></li></ul></li><li><a href=#linting>Linting</a><ul><li><a href=#mypy>mypy</a></li><li><a href=#pylint>pylint</a></li><li><a href=#flake8>flake8</a></li><li><a href=#ruff>Ruff</a></li></ul></li><li><a href=#testing--automation>Testing & Automation</a><ul><li><a href=#pytest>pytest</a></li><li><a href=#nox>nox</a></li></ul></li><li><a href=#profiling--benchmarking>Profiling & Benchmarking</a><ul><li><a href=#memray>memray</a></li><li><a href=#austin>Austin</a></li><li><a href=#py-spy>py-spy</a></li><li><a href=#the-python-profilers>The Python Profilers</a></li><li><a href=#memory-usage-over-time>Memory Usage Over Time</a></li><li><a href=#pytest-benchmark>pytest-benchmark</a></li><li><a href=#pytest-json-report>pytest-json-report</a></li></ul></li><li><a href=#packaging--deps>Packaging & Deps</a><ul><li><a href=#poetry>Poetry</a></li></ul></li><li><a href=#libraries>Libraries</a><ul><li><a href=#rich>rich</a></li><li><a href=#typer>typer</a></li><li><a href=#attrs>attrs</a></li><li><a href=#altair>Altair</a></li><li><a href=#pandas>Pandas</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Recently I was asked about Python tools & libraries that I use.
After taking the time to write a lengthy reply, I figured I might as well write a blog post, to make it more widely available.</p><p>This post is going to go over some Python tools & libraries that I use and that I like.</p><h2 id=formatting><a href=#formatting>Formatting<span hidden class=anchor aria-hidden=true href=#formatting>#</span></a></h2><p>Automatic formatting gives you the gift of not ever caring about formatting again.
Not when you resolve conflicts, not when you review code, not when you write code.</p><p>I currently use 3 different formatters to get it done. I run <code>autoflake</code>, then <code>isort</code>, then <code>black</code>.</p><h3 id=black><a href=#black>Black<span hidden class=anchor aria-hidden=true href=#black>#</span></a></h3><blockquote><p>The uncompromising Python code formatter</p></blockquote><p><a href=https://github.com/psf/black>Black</a> is a code-formatter for Python with minimal (line length) configurable settings.
It&rsquo;s a really good code formatter, and will help avoid all the &ldquo;but I like my code this way&rdquo; complaints.
Additionally, it&rsquo;s now more-or-less the de-facto standard for formatting Python code.</p><p>To paraphrase <a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&t=523s">Rob Pike</a>, &ldquo;Black&rsquo;s style is no one&rsquo;s favorite, yet Black is everyone&rsquo;s favorite.&rdquo;</p><h3 id=isort><a href=#isort>isort<span hidden class=anchor aria-hidden=true href=#isort>#</span></a></h3><p><a href=https://pycqa.github.io/isort/>isort</a> sorts your imports. It sorts them alphabetically, and also groups them separating standard-library, third-parties, and your own code.</p><p>Even if you don&rsquo;t care about sorting imports - it&rsquo;s going to solve a ton of import-duplication & merge-conflicts for you.</p><h3 id=autoflake><a href=#autoflake>autoflake<span hidden class=anchor aria-hidden=true href=#autoflake>#</span></a></h3><p><a href=https://github.com/PyCQA/autoflake>autoflake</a> removes unused imports. That&rsquo;s it. Use it.</p><h2 id=linting><a href=#linting>Linting<span hidden class=anchor aria-hidden=true href=#linting>#</span></a></h2><p>Just like automatic formatting - you don&rsquo;t need to think about anything you can lint for.
This also means you never need to argue about it.</p><h3 id=mypy><a href=#mypy>mypy<span hidden class=anchor aria-hidden=true href=#mypy>#</span></a></h3><p><a href=https://mypy-lang.org/>mypy</a> is a static type-checker for Python.
It uses type annotations & type inference to tell whether your types match or not.
It is not perfect, but it catches often catches major issues in my code.</p><p>I highly recommend using it in your project from the get-go.
Writing types as you code is easy.
Writing types for an existing project is exhausting.</p><p>While the default settings are ok, there are some extras I recommend:</p><ul><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-check_untyped_defs>check-untyped-defs</a> makes sure you get warnings even if you didn&rsquo;t annotate a function at all. This one, in particular, can be annoying to turn on late into a project.</li><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-strict_equality>strict-equality</a> warns you if you compare non-overlapping types. Those comparisons are usually bugs.</li><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-warn_return_any>warn-return-any</a> warns if you return an unknown type from a function annotated to return a specific type</li><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-warn_no_return>warn-no-return</a> warns if you only have <code>return</code> statements in <em>some</em> branches of your function. This is annoying sometimes, but saves you in the cases where you actually forget to return a value.</li><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-warn_unreachable>warn-unreachable</a> warns you when a piece of code is deemed unreachable. This one is super helpful in realizing that you made a typing error. Like checking a variable that&rsquo;s never <code>None</code> against <code>None</code>.</li></ul><p>And the make the output friendlier, use:</p><ul><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-pretty>pretty</a></li><li><a href=https://mypy.readthedocs.io/en/stable/config_file.html#confval-show_error_context>show-error-context</a></li></ul><h3 id=pylint><a href=#pylint>pylint<span hidden class=anchor aria-hidden=true href=#pylint>#</span></a></h3><p><a href=https://github.com/PyCQA/pylint>Pylint</a>, with it&rsquo;s catchy tag-line (&ldquo;It&rsquo;s not just a linter that annoys you!&rdquo;), is for the most part just a linter that annoys you.</p><p>If you set it up, and disable all the errors you don&rsquo;t care about (I have over 20 disabled globally), it can give some value. But it is also painfully slow.</p><p>It is currently here because I still use it, but I am more and more hesitant about including it in new projects.
I just don&rsquo;t feel like its value is worth the time and hassle.
Especially with <code>mypy</code> catching a lot of the true errors <code>pylint</code> catches.</p><h3 id=flake8><a href=#flake8>flake8<span hidden class=anchor aria-hidden=true href=#flake8>#</span></a></h3><p><a href=https://flake8.pycqa.org/en/latest/>flake8</a> is a style-guide-enforcer for Python.
It is fast and capable, and has a large assortment of plugins that can catch actual bugs as well.</p><h3 id=ruff><a href=#ruff>Ruff<span hidden class=anchor aria-hidden=true href=#ruff>#</span></a></h3><p><a href=https://github.com/charliermarsh/ruff>Ruff</a> is &ldquo;an extremely fast Python linter, written in Rust.&rdquo; And it lives up to that.
I don&rsquo;t have much experience with it in production, so I don&rsquo;t know how much it actually catches compared to the previous tools.</p><p>Ruff is now in <em>very</em> active development, and I plan to integrate it soon.
Even if it&rsquo;s missing some features you currently want, I think it&rsquo;s worth keeping an eye out for it.</p><h2 id=testing--automation><a href=#testing--automation>Testing & Automation<span hidden class=anchor aria-hidden=true href=#testing--automation>#</span></a></h2><h3 id=pytest><a href=#pytest>pytest<span hidden class=anchor aria-hidden=true href=#pytest>#</span></a></h3><p><a href=https://docs.pytest.org>Pytest</a> is my test-framework of choice.
The fixture-based design takes a while to get used to, and there is a bit of &ldquo;magic&rdquo; going on.
But once you get the hang of it, it is extremely capable and easy to use and extend.</p><h3 id=nox><a href=#nox>nox<span hidden class=anchor aria-hidden=true href=#nox>#</span></a></h3><p><a href=https://nox.thea.codes>nox</a> makes it easy to automate your tests for multiple Python environments (think multiple versions of Python, multiple OSs, etc.).</p><p>I find it straight-forward and easy to use and extend, as the configuration is entirely in Python.</p><p>In addition to tests, I use it to automate code formatting & linting, code-generation, and various CI tasks.
That way I know that what I run locally and in the CI uses the same code and configuration.</p><p>You can also read <a href=https://hynek.me/articles/why-i-like-nox/>Hynek Schlawack&rsquo;s post on nox</a>.</p><h2 id=profiling--benchmarking><a href=#profiling--benchmarking>Profiling & Benchmarking<span hidden class=anchor aria-hidden=true href=#profiling--benchmarking>#</span></a></h2><h3 id=memray><a href=#memray>memray<span hidden class=anchor aria-hidden=true href=#memray>#</span></a></h3><p><a href=https://bloomberg.github.io/memray/getting_started.html>Memray</a> is a memory profiler for Python. It does what it says on the tin, and does it well.
It shows you which parts of your code allocated the most memory, and allows you to easily analyze that using multiple &ldquo;reporters&rdquo;.
My most-used reporters are the <a href=https://bloomberg.github.io/memray/flamegraph.html>Flame Graph Reporter</a> and the <a href=https://bloomberg.github.io/memray/tree.html>Tree Reporter</a>.</p><p>The only major downside is that it does not support Windows (unless you&rsquo;re using WSL).</p><h3 id=austin><a href=#austin>Austin<span hidden class=anchor aria-hidden=true href=#austin>#</span></a></h3><p><a href=https://github.com/P403n1x87/austin>Austin</a> is a sampling profiler for Python. It is fast and capable, and I use it a lot.</p><p>Be aware that some related tools (austin-web) are not always as up-to-date and may cause issues.</p><p>I recommend using it to profile an entire run, and then use <a href=https://www.speedscope.app/>Speedscope</a> to analyze it.
If you need to analyze a part of a run [austin-tui][] can show a live view, and then save it to a trace file.</p><p>The default output format for Austin is supported by Speedscope and is also easily editable using scripts (if you want to filter out specific parts of a run).</p><h3 id=py-spy><a href=#py-spy>py-spy<span hidden class=anchor aria-hidden=true href=#py-spy>#</span></a></h3><p><a href=https://github.com/benfred/py-spy>py-spy</a> is another sampling profiler for Python.
For me, it&rsquo;s main benefit is it&rsquo;s <code>top</code> view, which gives a good overview of a process and lets you know &ldquo;what&rsquo;s taking so long?&rdquo;.
Additionally, it can show you stack traces for all the currently running threads.</p><p>I usually use it when a running process misbehaves and I want to know why.</p><h3 id=the-python-profilers><a href=#the-python-profilers>The Python Profilers<span hidden class=anchor aria-hidden=true href=#the-python-profilers>#</span></a></h3><p><a href=https://docs.python.org/3/library/profile.html>The Python Profilers</a> are for when sampling profilers aren&rsquo;t enough.
You need to know the call-count, and not just the durations.
They don&rsquo;t sample, so they will severely affect your program&rsquo;s runtime.
But there is no real alternative.</p><p>For viewing and analyzing the data, I highly recommend using <a href=https://kcachegrind.github.io/html/Home.html>KCacheGrind</a> (or possible <a href=https://sourceforge.net/projects/qcachegrindwin/>QCacheGrind</a> if you&rsquo;re on Windows and don&rsquo;t wanna bother with setting up GUI for WSL). It is extremely fast even with very large profiles, and has some very good visualizations for analyzing the data. To convert the data to a fitting format, use <a href=https://pypi.org/project/pyprof2calltree/>pyprof2calltree</a></p><h3 id=memory-usage-over-time><a href=#memory-usage-over-time>Memory Usage Over Time<span hidden class=anchor aria-hidden=true href=#memory-usage-over-time>#</span></a></h3><p>Sometimes the simplest solution is the best one.</p><p>When I need to find the part in my code that suddenly allocates way to much - I often log my memory usage over time, graph it, then compare it with a log or a sampling-profiler run to see which part of the run correlates with the spike in memory usage.</p><p>It&rsquo;s crude, but it works.</p><p>I tend to use the <a href=https://pypi.org/project/psutil/><code>psutil</code></a> library for it.</p><h3 id=pytest-benchmark><a href=#pytest-benchmark>pytest-benchmark<span hidden class=anchor aria-hidden=true href=#pytest-benchmark>#</span></a></h3><p><a href=https://pypi.org/project/pytest-benchmark/>pytest-benchmark</a> allows you to easily run short-benchmarks in your test-suite. It takes care of all the complicated stuff - repeating the runs, and calculating statistics - and gives you easy-to-read results.</p><p>I also wrote a small tool on top of it to perform comparative-benchmarks and compare different implementations for the same code. You can find it at <a href=https://github.com/tmr232/python-benchmark>tmr232/python-benchmark</a>.</p><h3 id=pytest-json-report><a href=#pytest-json-report>pytest-json-report<span hidden class=anchor aria-hidden=true href=#pytest-json-report>#</span></a></h3><p><a href=https://pypi.org/project/pytest-json-report/>pytest-json-report</a> generates a JSON report for a pytest run. It has 2 main benefits:</p><ol><li>Makes it easy to parse the test results and create custom reports</li><li>Makes it easy to add extra information into the test results</li></ol><p>I use it to add peak-memory-usage into the test-results, so that I can keep track of that.</p><h2 id=packaging--deps><a href=#packaging--deps>Packaging & Deps<span hidden class=anchor aria-hidden=true href=#packaging--deps>#</span></a></h2><h3 id=poetry><a href=#poetry>Poetry<span hidden class=anchor aria-hidden=true href=#poetry>#</span></a></h3><p><a href=https://python-poetry.org/>Poetry</a> is my go-to for managing my Python dependencies.</p><p>The main advantage of Poetry over other tools is that it automatically maintains a lock-file for you.
By committing the lock-file into your repo, you ensure that package versions will be identical across all your environments.
That way you know that what you develop with locally is the same as what&rsquo;s tested in the CI, same as what&rsquo;s deployed to staging, and also the same as what you deploy to production.</p><p>I think that this alone should be enough to convince you.</p><h2 id=libraries><a href=#libraries>Libraries<span hidden class=anchor aria-hidden=true href=#libraries>#</span></a></h2><h3 id=rich><a href=#rich>rich<span hidden class=anchor aria-hidden=true href=#rich>#</span></a></h3><p><a href=https://github.com/Textualize/rich>Rich</a> is a Python library for rich text and beautiful formatting in the terminal.</p><p>If you print anything to the terminal - use Rich.
It&rsquo;s better than any other library in the category.</p><h3 id=typer><a href=#typer>typer<span hidden class=anchor aria-hidden=true href=#typer>#</span></a></h3><p><a href=https://typer.tiangolo.com/>Typer</a>, from the creator of <a href=https://fastapi.tiangolo.com/>FastAPI</a>, makes building advanced CLIs easy and painless.</p><p>In it&rsquo;s most basic - it takes the argument names and type annotations from a function, and converts it to a fully-features CLI (flags, arguments, documentation, completions).</p><h3 id=attrs><a href=#attrs>attrs<span hidden class=anchor aria-hidden=true href=#attrs>#</span></a></h3><p><a href=https://www.attrs.org/en/stable/>attrs</a> is my preferred way to write Python classes. It uses type annotations to declaratively define your classes, and does a fantastic work of deducing extra functionality from it (comparisons, equality, hash&mldr;).</p><p>To keep things short - I don&rsquo;t remember the last time I wrote an <code>__init__</code> method.</p><h3 id=altair><a href=#altair>Altair<span hidden class=anchor aria-hidden=true href=#altair>#</span></a></h3><p>If you ever need to draw a graph, use <a href=https://altair-viz.github.io/>Altair</a>.</p><p>For it&rsquo;s philosophy and a brief intro, I recommend watching <a href="https://www.youtube.com/watch?v=vTingdk_pVM">How to Think about Data Visualization</a> by Jake VanderPlas.</p><p>The only downside I found so far is that exporting an image usually requires a web-browser in the process. But if your final output is HTML - you should be good.</p><h3 id=pandas><a href=#pandas>Pandas<span hidden class=anchor aria-hidden=true href=#pandas>#</span></a></h3><p>Yes, <a href=https://pandas.pydata.org/>pandas</a>, the data-frame library.</p><p>If you&rsquo;re ever dealing with numeric data, it&rsquo;s worth spending the time (a couple of days, in my case) to develop basic competency with pandas.
Once you have that, a lot of annoying tasks that you used to do in Excel become easy and straightforward.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tamir.dev/>Tamir Bahar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>